<!DOCTYPE html>
<html 
	lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> B样条 -  KK空间</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="/image/fa.jpeg"
			type="image/jpeg"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<!-- hexo injector head_end start -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$']],
          displayMath: [['$$', '$$']],
          processEscapes: true
        }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
    <!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>

	<body>
		<div
			class="kira-background"
			style="background-image: url('/image/frieren.png')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="KK空间">
        <img
			src="/image/chongye.png"
			alt="战斗包子"
		/>
    </a>
</div>
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a href="/image/chongye.png" title="战斗包子">
			<img
				src="/image/chongye.png"
				alt="战斗包子"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>113</div>
		<div><span>标签</span>8</div>
		<div><span>分类</span>5</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/"
			title="回到首页"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				回到首页
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive.html"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about.html"
			title="关于本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				关于本人
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/friends.html"
			title="我的朋友"
		>
			<i
				class="kirafont
					
						icon-team
					"
			></i>
			<div class="kira-list-item-content">
				我的朋友
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/todolist.html"
			title="我的Todo"
		>
			<i
				class="kirafont
					
						icon-container-fill
					"
			></i>
			<div class="kira-list-item-content">
				我的Todo
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/games/"
			title="游戏卡片"
		>
			<i
				class="kirafont
					
						icon-fullscreen
					"
			></i>
			<div class="kira-list-item-content">
				游戏卡片
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/game_graph.html"
			title="小图"
		>
			<i
				class="kirafont
					
						icon-fullscreen
					"
			></i>
			<div class="kira-list-item-content">
				小图
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1040035659&website=www.oicqzone.com"
				target="_blank"
				mdui-tooltip="{content: 'QQ'}"
				style="color: rgb(49, 174, 255); background-color: rgba(49, 174, 255, .1);"
			>
				<i
					class="kirafont
					
						icon-QQ
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://space.bilibili.com/6456506"
				target="_blank"
				mdui-tooltip="{content: '哔哩哔哩'}"
				style="color: rgb(231, 106, 141); background-color: rgba(231, 106, 141, .15);"
			>
				<i
					class="kirafont
					
						icon-bilibili
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/PaiPai121/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://gitee.com/<你的gitee id>"
				target="_blank"
				mdui-tooltip="{content: 'Gitee'}"
				style="color: rgb(165, 15, 15); background-color: rgba(165, 15, 15, .15);"
			>
				<i
					class="kirafont
					
						icon-gitee
					"
				></i>
			</a>
		
	</div>
</div>

		
			
  <div class="kira-widget-wrap">
    <h3 class="kira-widget-title">分类</h3>
    <div class="kira-widget">
      <ul class="category-list">
        
        

        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/业余开发/">
              业余开发
            </a>
            <span class="category-list-count">12</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/学习/">
              学习
            </a>
            <span class="category-list-count">19</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/工作体验/">
              工作体验
            </a>
            <span class="category-list-count">42</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/日常生活/">
              日常生活
            </a>
            <span class="category-list-count">25</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/游戏评测/">
              游戏评测
            </a>
            <span class="category-list-count">14</span>
          </li>
        
      </ul>
    </div>
  </div>

		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/" style="font-size: 16.67px;">技术学习</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E4%B8%9A%E4%BD%99%E5%BC%80%E5%8F%91/" style="font-size: 18.33px;">游戏业余开发</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E8%A1%8D%E7%94%9F/" style="font-size: 10px;">游戏衍生</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E8%AF%84%E6%B5%8B/" style="font-size: 15px;">游戏评测</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/" style="font-size: 11.67px;">生活感悟</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/" style="font-size: 13.33px;">生活记录</a> <a href="/tags/%E8%81%8C%E5%9C%BA%E7%BB%8F%E9%AA%8C/" style="font-size: 20px;">职场经验</a> <a href="/tags/%E8%A1%8C%E4%B8%9A%E8%A7%82%E5%AF%9F/" style="font-size: 20px;">行业观察</a>
		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			文章归档
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/">2026</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">51</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">13</span></li></ul>
		</div>
	</div>


		
	</aside>
	<div class="kira-copyright">
		&copy; 2026
		<a href="/">战斗包子</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		
	</div>
</div>
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div class="kira-post-cover">
			<img
				data-src="/image/mleva.jpg"
				data-sizes="auto"
				alt="B样条"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>B样条</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2025年11月02日</a>
			<a><i class="kirafont icon-edit-fill"></i>8.4k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 38 分钟</a>
		</div>
		<!-- toc --><html><head></head><body><ul>
<li><a href="#b%E6%A0%B7%E6%9D%A1b-spline%E7%AC%94%E8%AE%B0">B样条（B-Spline）笔记</a>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a>
<ul>
<li><a href="#1-%E7%9B%AE%E6%A0%87b%E6%A0%B7%E6%9D%A1%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88">1. 目标：B样条用来做什么？</a></li>
<li><a href="#2-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E4%B8%80%E4%B8%AA%E7%9B%B4%E8%A7%82%E7%9A%84%E6%AF%94%E5%96%BB">2. 核心思想：一个直观的比喻</a></li>
<li><a href="#3-b%E6%A0%B7%E6%9D%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5">3. B样条的几个概念</a>
<ul>
<li><a href="#a-%E6%8E%A7%E5%88%B6%E7%82%B9-control-points">a. 控制点 (Control Points)</a></li>
<li><a href="#b-%E6%AC%A1%E6%95%B0-degree--%E9%98%B6%E6%95%B0-order">b. 次数 (Degree) / 阶数 (Order)</a></li>
<li><a href="#c-%E8%8A%82%E7%82%B9%E5%90%91%E9%87%8F-knot-vector">c. 节点向量 (Knot Vector)</a></li>
<li><a href="#d-%E5%B1%80%E9%83%A8%E6%8E%A7%E5%88%B6%E6%80%A7-local-control">d. 局部控制性 (Local Control)</a></li>
</ul>
</li>
<li><a href="#4-b%E6%A0%B7%E6%9D%A1-vs-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF-bezier">4. B样条 vs. 贝塞尔曲线 (Bézier)</a></li>
<li><a href="#5-%E6%80%BB%E7%BB%93%E4%B8%BA%E4%BB%80%E4%B9%88b%E6%A0%B7%E6%9D%A1%E8%BF%99%E4%B9%88%E9%87%8D%E8%A6%81">5. 总结：为什么B样条这么重要？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#b%E6%A0%B7%E6%9D%A1%E5%92%8C%E8%B4%9D%E5%A1%9E%E5%B0%94%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84">B样条和贝塞尔的转换、递推公式与矩阵的转换（实际代码需要用到的）</a></li>
<li><a href="#b%E6%A0%B7%E6%9D%A1%E6%A0%B8%E5%BF%83m-%E5%9F%BA%E7%A1%80%E7%9F%A9%E9%98%B5basis-matrix">B样条核心：M 基础矩阵（Basis Matrix）</a>
<ul>
<li><a href="#part-1-m-%E7%9F%A9%E9%98%B5%E6%98%AF%E4%BB%80%E4%B9%88">Part 1: M 矩阵是什么？</a>
<ul>
<li><a href="#%E4%B8%A4%E7%A7%8D%E6%8F%8F%E8%BF%B0%E6%9B%B2%E7%BA%BF%E7%9A%84%E8%AF%AD%E8%A8%80">两种描述曲线的“语言”</a>
<ul>
<li><a href="#%E8%AF%AD%E8%A8%80-1b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84%E8%AF%AD%E8%A8%80%E7%94%A8%E6%8E%A7%E5%88%B6%E7%82%B9%E6%8F%8F%E8%BF%B0%E6%9B%B2%E7%BA%BF">语言 1：B样条基（设计师的语言：用控制点描述曲线）</a></li>
<li><a href="#%E8%AF%AD%E8%A8%80-2%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9F%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%AF%AD%E8%A8%80%E7%94%A8%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%8F%E8%BF%B0%E6%9B%B2%E7%BA%BF">语言 2：多项式基（计算机的语言：用多项式描述曲线）</a></li>
</ul>
</li>
<li><a href="#m-%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AE%9A%E4%B9%89">M 矩阵的定义</a></li>
</ul>
</li>
<li><a href="#part-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BE%97%E5%88%B0-m-%E7%9F%A9%E9%98%B5">Part 2: 为什么要得到 M 矩阵？</a></li>
<li><a href="#part-3-%E6%80%8E%E4%B9%88%E5%BE%97%E5%88%B0-m-%E7%9F%A9%E9%98%B5">Part 3: 怎么得到 M 矩阵？</a>
<ul>
<li><a href="#%E6%8E%A8%E5%AF%BC%E6%96%B9%E6%B3%95%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80">推导方法：泰勒展开</a></li>
<li><a href="#cal_m-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88"><code>cal_M</code> 函数在做什么？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#b%E6%A0%B7%E6%9D%A1%E4%B8%8E%E8%B4%9D%E5%A1%9E%E5%B0%94%E7%9A%84%E8%BD%AC%E6%8D%A2">B样条与贝塞尔的转换</a>
<ul>
<li><a href="#step-1-%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">Step 1: 需要解决的问题：</a></li>
<li><a href="#step-2-%E6%98%8E%E7%A1%AE%E7%9B%AE%E6%A0%87%E5%BB%BA%E7%AB%8B%E7%BA%A6%E6%9D%9F%E7%BF%BB%E8%AF%91">Step 2: 明确目标（建立“约束翻译”）</a></li>
<li><a href="#step-3-%E6%8E%A8%E5%AF%BC%E7%BF%BB%E8%AF%91%E7%9F%A9%E9%98%B5-%E4%BD%A0%E9%97%AE%E7%9A%84-a_trans_temp">Step 3: 推导“翻译矩阵” (你问的 <code>A_trans_temp</code>)</a>
<ul>
<li><a href="#step-4-%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">Step 4: 完整的设计流程（代码实现）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%99%84%E5%BD%95">附录</a>
<ul>
<li><a href="#%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5">转换矩阵</a></li>
</ul>
</li>
<li><a href="#b%E6%A0%B7%E6%9D%A1%E6%A0%B8%E5%BF%83%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6%E7%82%B9%E6%9B%B2%E7%BA%BF%E6%AE%B5%E6%95%B0%E4%B8%8E%E6%AC%A1%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB">B样条核心：节点、控制点、曲线段数与次数的关系</a>
<ul>
<li><a href="#%E8%BF%99%E5%A5%97%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9B%B4%E7%9B%B4%E8%A7%82">这套代码中的实现（更直观）</a>
<ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E5%85%AC%E5%BC%8F%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84">核心公式（代码中的）</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B8%AA%E5%85%AC%E5%BC%8F%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84">为什么这个公式是正确的？</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E8%BF%99%E4%B8%AA%E5%85%B3%E7%B3%BB">代码中如何定义这个关系</a></li>
</ul>
</li>
<li><a href="#%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAhessian%E5%92%8C%E7%BA%A6%E6%9D%9F">本项目如何构建hessian和约束</a>
<ul>
<li><a href="#%E4%BD%8D%E7%BD%AE%E6%88%90%E6%9C%AC">位置成本</a></li>
<li><a href="#%E8%88%AA%E5%90%91%E6%88%90%E6%9C%AC-pointcost_v_">航向成本 (PointCost_v_)</a></li>
<li><a href="#%E5%8A%A0%E9%80%9F%E5%BA%A6%E6%9B%B2%E7%8E%87%E6%88%90%E6%9C%AC-pointcost_a_">加速度/曲率成本 (PointCost_a_)</a></li>
<li><a href="#jerk-%E5%92%8C-snap-%E6%88%90%E6%9C%AC-pointcost_j_-pointcost_s_">Jerk 和 Snap 成本 (PointCost_j_, PointCost_s_)</a>
<ul>
<li><a href="#%E7%9B%B8%E5%85%B3%E7%9F%A9%E9%98%B5%E7%9A%84%E8%8E%B7%E5%BE%97">相关矩阵的获得</a></li>
<li><a href="#b%E6%A0%B7%E6%9D%A1%E7%9A%84%E6%B1%82%E5%AF%BC%E5%92%8C%E5%B7%AE%E5%88%86">B样条的求导和差分</a></li>
<li><a href="#n%E7%9F%A9%E9%98%B5%E6%9E%84%E6%88%90">N矩阵构成</a></li>
</ul>
</li>
<li><a href="#%E7%BA%A6%E6%9D%9F%E6%9E%84%E5%BB%BA">约束构建</a>
<ul>
<li><a href="#%E4%BD%8D%E7%BD%AE%E7%BA%A6%E6%9D%9F">位置约束</a></li>
<li><a href="#heading%E7%BA%A6%E6%9D%9F">heading约束</a></li>
<li><a href="#%E6%9B%B2%E7%8E%87%E7%BA%A6%E6%9D%9F">曲率约束</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="b%E6%A0%B7%E6%9D%A1b-spline%E7%AC%94%E8%AE%B0">B样条（B-Spline）笔记</span></h1>
<h2><span id="%E6%A6%82%E8%BF%B0">概述</span></h2>
<h3><span id="1-%E7%9B%AE%E6%A0%87b%E6%A0%B7%E6%9D%A1%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88">1. 目标：B样条用来做什么？</span></h3>
<p>在最基础的层面上，B样条（B-Spline，即 Basis Spline）是一种<strong>通过一组“控制点”来定义平滑曲线的数学方法。</strong></p>
<p>想象一下：</p>
<ul>
<li><strong>问题</strong>：你需要在计算机上绘制一条复杂的、非常平滑的曲线，比如汽车的流线型车身、一个漂亮的字体，或者一条机器人的运动轨迹。</li>
<li><strong>B样条的解决方案</strong>：你不需要定义曲线上成千上万个点的坐标，你只需要在曲线“大致”经过的地方放几个<strong>控制点</strong>，B样条算法就会自动帮你“脑补”出一条穿梭于这些点之间的、数学上完美的平滑曲线。</li>
</ul>
<h3><span id="2-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E4%B8%80%E4%B8%AA%E7%9B%B4%E8%A7%82%E7%9A%84%E6%AF%94%E5%96%BB">2. 核心思想：一个直观的比喻</span></h3>
<p>理解B样条最简单的方法是“磁铁”和“弹性尺”的比喻：</p>
<ol>
<li><strong>控制点 (Control Points)</strong>：想象它们是一块块<strong>磁铁</strong>，你把它们放在桌子上。</li>
<li><strong>B样条曲线</strong>：想象你有一根<strong>弹性的、灵活的尺子</strong>（“Spline”这个词的本意就是“细木条”或“样条”，是造船时用来画船体曲线的工具）。</li>
<li><strong>生成曲线</strong>：你把这根弹性尺“扔”到磁铁附近。尺子会因为磁铁的吸引力而<strong>弯曲</strong>，朝着磁铁的方向靠近，但<strong>不一定会碰到</strong>每一块磁铁（除非磁铁吸力特别强）。</li>
</ol>
<p>最终，这根弹性尺形成的那个<strong>平滑的、被磁力吸引而弯曲的形状</strong>，就是B样条曲线。</p>
<ul>
<li>你移动一块磁铁（控制点），尺子（曲线）的形状就会<strong>局部</strong>发生平滑的变化。</li>
</ul>
<h3><span id="3-b%E6%A0%B7%E6%9D%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E6%A6%82%E5%BF%B5">3. B样条的几个概念</span></h3>
<h4><span id="a-%E6%8E%A7%E5%88%B6%E7%82%B9-control-points">a. 控制点 (Control Points)</span></h4>
<ul>
<li>这就是上面比喻中的“磁铁”。</li>
<li>它们是B样条的**“骨架”<strong>。将所有控制点按顺序“连连看”形成的折线，被称为</strong>控制多边形 (Control Polygon)**。</li>
<li>B样条曲线<strong>总是</strong>被完全包含在它的控制多边形的“凸包”内（Convex Hull Property）。简单说，曲线永远不会“飞出”它的控制点所框定的大致范围。</li>
</ul>
<h4><span id="b-%E6%AC%A1%E6%95%B0-degree--%E9%98%B6%E6%95%B0-order">b. 次数 (Degree) / 阶数 (Order)</span></h4>
<p>这是一个<strong>非常重要</strong>的设置项，它决定了曲线的**“平滑等级”**。</p>
<ul>
<li>
<p><strong>关系</strong>：<code>阶数 (Order) = 次数 (Degree) + 1</code>。（在你的代码中，<code>B_spline_order 5</code> 指的是阶数，所以它是一个4次样条。<em>注：请再次核对你的代码，<code>B_spline_order 5</code> 通常指k=5，即<strong>5次</strong>，Order=6</em>。我们假设你的代码中 <code>B_spline_order</code> 指的是<strong>次数 (Degree=k)</strong>，即5次样条，Order=6。）</p>
<ul>
<li><em>（为避免混淆，我们下面统一使用“次数”）</em></li>
</ul>
</li>
<li>
<p><strong>次数 (k=1), 线性</strong>：曲线就是控制多边形本身（一堆直线）。非常“硬”。</p>
</li>
<li>
<p><strong>次数 (k=2), 二次</strong>：曲线由抛物线段构成。开始变得平滑。</p>
</li>
<li>
<p><strong>次数 (k=3), 三次 (Cubic)</strong>：<strong>这是最常用的！</strong> 比如 Adobe Illustrator、CAD软件、字体设计默认都是它。它在“平滑度”和“控制性”之间达到了完美的平衡。</p>
</li>
<li>
<p><strong>次数 (k=5), 五次 (Quintic)</strong>：<strong>（这就是你代码中用的）</strong> 这是一个非常高等级的平滑。为什么用这么高？因为五次样条（六阶）能保证它的**“加加速度（Jerk）”和“加加加速度（Snap）”<strong>也是平滑的。在机器人或自动驾驶路径规划中，这意味着</strong>极高的乘坐舒适度**，机器或车辆在执行轨迹时不会有突然的“抖动”。</p>
</li>
</ul>
<h4><span id="c-%E8%8A%82%E7%82%B9%E5%90%91%E9%87%8F-knot-vector">c. 节点向量 (Knot Vector)</span></h4>
<ul>
<li>这是B样条<strong>最强大、也最难理解</strong>的概念。</li>
<li><strong>比喻</strong>：如果说控制点是“磁铁”，那么节点向量就是一本**“规则手册”<strong>，它详细规定了</strong>每一个控制点从哪里开始生效，到哪里结束生效**。</li>
<li>它是一个<strong>数字列表</strong>（必须是<strong>非递减</strong>的），例如：<code>[0, 0, 0, 0, 1, 2, 3, 4, 4, 4, 4]</code> (对于一个3次样条)。</li>
<li><strong>它的作用</strong>：
<ol>
<li><strong>定义曲线的“分段点”</strong>：<code>[...0, 1, 2, 3, 4...]</code> 这些变化的值，定义了曲线在参数 t 上的分段。</li>
<li><strong>控制“端点”行为</strong>：
<ul>
<li>你注意到开头有4个 <code>0</code>，结尾有4个 <code>4</code> 吗？</li>
<li><strong>规则</strong>：如果一个节点值（如<code>0</code>）重复了 <code>k</code> 次（<code>k</code> = 次数），那么曲线将<strong>精确地穿过</strong>它对应的那个控制点。</li>
<li>所以，<code>[0, 0, 0, 0, ...]</code>（开头重复 <code>k+1</code> 次，这里是4次） $\implies$ 曲线<strong>必须从第一个控制点开始</strong>。</li>
<li><code>[... 4, 4, 4, 4]</code>（结尾重复 <code>k+1</code> 次） $\implies$ 曲线<strong>必须在最后一个控制点结束</strong>。</li>
<li>这种两端“锁死”的B样条，也称为**“Clamped” B-spline（钳位B样条）**。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4><span id="d-%E5%B1%80%E9%83%A8%E6%8E%A7%E5%88%B6%E6%80%A7-local-control">d. 局部控制性 (Local Control)</span></h4>
<p><strong>这是B样条相对贝塞尔曲线（Bézier）的“杀手锏”功能。</strong></p>
<ul>
<li><strong>贝塞尔曲线的问题</strong>：在一条（单一的）贝塞尔曲线中，你移动 <em>任何一个</em> 控制点，<em>整条曲线</em>（从头到尾）都会发生变化。这叫“全局修改”。</li>
<li><strong>B样条的优势</strong>：由于“节点向量”这本规则手册的存在，每个控制点</li>
</ul>
<p>$$C_i$$
的“磁力”<strong>只在曲线的一小段上有效</strong>。</p>
<ul>
<li><strong>结果</strong>：如果你有一条由100个控制点定义的曲线，你移动<strong>第50号</strong>控制点，只有它附近（比如48号到52号）那<strong>一小段</strong>曲线会跟着变形。曲线的开头和结尾（比如1号点和100号点）<strong>完全不会动</strong>。</li>
</ul>
<p>这对于精确调整一个复杂曲线的局部细节（比如在规划路径时躲避一个小障碍物）是至关重要的。</p>
<h3><span id="4-b%E6%A0%B7%E6%9D%A1-vs-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF-bezier">4. B样条 vs. 贝塞尔曲线 (Bézier)</span></h3>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">贝塞尔曲线 (Bézier Curve)</th>
<th style="text-align:left">B样条 (B-Spline)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>控制性</strong></td>
<td style="text-align:left"><strong>全局控制</strong> (移动一个点，整条线都变)</td>
<td style="text-align:left"><strong>局部控制</strong> (移动一个点，只变一小段)</td>
</tr>
<tr>
<td style="text-align:left"><strong>端点</strong></td>
<td style="text-align:left"><strong>总是</strong>穿过第一个和最后一个控制点</td>
<td style="text-align:left"><strong>不一定</strong>穿过 (除非用节点向量“钳住”它)</td>
</tr>
<tr>
<td style="text-align:left"><strong>复杂度</strong></td>
<td style="text-align:left">更简单，不需要“节点向量”</td>
<td style="text-align:left">更复杂，但功能更强大</td>
</tr>
<tr>
<td style="text-align:left"><strong>关系</strong></td>
<td style="text-align:left">贝塞尔曲线是B样条的一种<strong>特例</strong></td>
<td style="text-align:left">B样条是贝塞尔曲线的<strong>推广</strong></td>
</tr>
</tbody>
</table>
<h3><span id="5-%E6%80%BB%E7%BB%93%E4%B8%BA%E4%BB%80%E4%B9%88b%E6%A0%B7%E6%9D%A1%E8%BF%99%E4%B9%88%E9%87%8D%E8%A6%81">5. 总结：为什么B样条这么重要？</span></h3>
<ol>
<li><strong>局部控制</strong>：最核心的优势。允许你精细、安全地修改复杂曲线。</li>
<li><strong>平滑度可控</strong>：你可以通过“次数”来精确定义你需要的平滑等级（例如，自动驾驶需要“Jerk平滑”，就用5次）。</li>
<li><strong>通用性</strong>：它是一种“统一”的数学表达。它可以完美地表示一条直线、一个圆、一条贝塞尔曲线，或者一条极其复杂的有机曲线。</li>
</ol>
<h1><span id="b%E6%A0%B7%E6%9D%A1%E5%92%8C%E8%B4%9D%E5%A1%9E%E5%B0%94%E7%9A%84%E8%BD%AC%E6%8D%A2%E9%80%92%E6%8E%A8%E5%85%AC%E5%BC%8F%E4%B8%8E%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%99%85%E4%BB%A3%E7%A0%81%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84">B样条和贝塞尔的转换、递推公式与矩阵的转换（实际代码需要用到的）</span></h1>
<h1><span id="b%E6%A0%B7%E6%9D%A1%E6%A0%B8%E5%BF%83m-%E5%9F%BA%E7%A1%80%E7%9F%A9%E9%98%B5basis-matrix">B样条核心：M 基础矩阵（Basis Matrix）</span></h1>
<h2><span id="part-1-m-%E7%9F%A9%E9%98%B5%E6%98%AF%E4%BB%80%E4%B9%88">Part 1: M 矩阵是什么？</span></h2>
<p>$M$矩阵是一个**“翻译官”<strong>，它的唯一工作就是</strong>“基变换” (Change of Basis)**。</p>
<p>具体来说，它负责将B样条的**“控制点语言”<strong>翻译成计算机最喜欢的</strong>“多项式语言”**。</p>
<hr>
<h3><span id="%E4%B8%A4%E7%A7%8D%E6%8F%8F%E8%BF%B0%E6%9B%B2%E7%BA%BF%E7%9A%84%E8%AF%AD%E8%A8%80">两种描述曲线的“语言”</span></h3>
<p>想象我们有两种方式来描述同一条平滑曲线：</p>
<h4><span id="%E8%AF%AD%E8%A8%80-1b%E6%A0%B7%E6%9D%A1%E5%9F%BA%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84%E8%AF%AD%E8%A8%80%E7%94%A8%E6%8E%A7%E5%88%B6%E7%82%B9%E6%8F%8F%E8%BF%B0%E6%9B%B2%E7%BA%BF">语言 1：B样条基（设计师的语言：用控制点描述曲线）</span></h4>
<ul>
<li><strong>公式</strong>：</li>
</ul>
<p>$$P(t) = C_0 \cdot N_{0,k}(t) + C_1 \cdot N_{1,k}(t) + \dots + C_k \cdot N_{k,k}(t)$$</p>
<ul>
<li><strong>变量</strong>：</li>
<li></li>
</ul>
<p>$$C$$
(一个包含<code>k+1</code>个<strong>控制点</strong>的向量)。</p>
<ul>
<li><strong>优点</strong>：非常直观，具有“局部控制性”。</li>
<li><strong>缺点</strong>：计算</li>
</ul>
<p>$$N_{i,k}(t)$$
（基函数）非常缓慢，因为它是一个复杂的递归函数。</p>
<h4><span id="%E8%AF%AD%E8%A8%80-2%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9F%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%AF%AD%E8%A8%80%E7%94%A8%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%8F%E8%BF%B0%E6%9B%B2%E7%BA%BF">语言 2：多项式基（计算机的语言：用多项式描述曲线）</span></h4>
<ul>
<li><strong>公式</strong>：</li>
</ul>
<p>$$P(t) = A_0 + A_1 \cdot t + A_2 \cdot t^2 + \dots + A_k \cdot t^k$$</p>
<ul>
<li><strong>变量</strong>：</li>
</ul>
<p>$$A$$
(一个包含 $k+1$ 个<strong>多项式系数</strong>的向量)。</p>
<ul>
<li><strong>优点</strong>：计算<strong>极其快速</strong>，计算机硬件天生就擅长这个。</li>
<li><strong>缺点</strong>：非常不直观，改一个系数 $A_2$，整条曲线都会变。</li>
</ul>
<hr>
<h3><span id="m-%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AE%9A%E4%B9%89">M 矩阵的定义</span></h3>
<p>$M$ 矩阵就是连接这两种语言的**“翻译矩阵”**。</p>
<p>B样条理论证明，对于同一条曲线段，它的多项式系数 $A$ 和它的B样条控制点 $C$ 之间，存在一个固定的线性关系：</p>
<p>$$A = M \cdot C$$</p>
<p>或者用向量形式表示：</p>
<p>$$\begin{bmatrix} A_0 \\ A_1 \\ \vdots \\ A_k \end{bmatrix} = \begin{bmatrix} M_{0,0} &amp; M_{0,1} &amp; \dots &amp; M_{0,k} \\ M_{1,0} &amp; M_{1,1} &amp; \dots &amp; M_{1,k} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ M_{k,0} &amp; M_{k,1} &amp; \dots &amp; M_{k,k} \end{bmatrix} \cdot \begin{bmatrix} C_0 \\ C_1 \\ \vdots \\ C_k \end{bmatrix}$$</p>
<p><strong>因此，$M$ 矩阵是一个常量矩阵，它将B样条控制点向量 $C$ 转换为等效的多项式系数向量 $A$。</strong></p>
<p>在代码中，<code>M_pos_</code>、<code>this-&gt;M</code> 就是这个 $M$ 矩阵。<code>cal_M</code> 函数 就是用来在程序启动时，根据数学公式计算出这个矩阵。</p>
<h2><span id="part-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BE%97%E5%88%B0-m-%E7%9F%A9%E9%98%B5">Part 2: 为什么要得到 M 矩阵？</span></h2>
<p>答案：<strong>为了追求极致的计算速度。</strong></p>
<p>有了 $M$ 矩阵，我们就把一个“递归”问题（慢）转换成了一个“多项式求值”问题（快）。</p>
<p>在自动驾驶或机器人中，我们每秒可能需要重新规划几十次路径。如果每次计算一个点的位置，都需要从B样条最基础的递归公式（$N(t)$）开始，计算量会大到无法接受。</p>
<p>现在的工作流程变得飞快：</p>
<ol>
<li><strong>程序启动时</strong>：调用一次 <code>cal_M()</code>，计算这个“翻译官” $M$。</li>
<li><strong>优化器运行时</strong>：当需要计算 $t=0.5$ 处的点时：</li>
</ol>
<p><strong>旧的慢方法</strong>：费力地计算</p>
<p>$$N_{0,5}(0.5), N_{1,5}(0.5), \dots$$</p>
<p><strong>新的快方法</strong>（代码 <code>Get_line_position</code> 正是这么做的）：
1.  <code>A = M * C</code> (一次矩阵乘法，得到多项式系数)
2.  <code>P(0.5) = A_0 + A_1 \cdot 0.5 + A_2 \cdot (0.5)^2 + \dots</code> (几次乘法和加法)</p>
<p><strong>结论：$M$ 矩阵是B样条在工程中得以高速应用（尤其是在优化问题中）的关键。</strong></p>
<h2><span id="part-3-%E6%80%8E%E4%B9%88%E5%BE%97%E5%88%B0-m-%E7%9F%A9%E9%98%B5">Part 3: 怎么得到 M 矩阵？</span></h2>
<p><strong>$M$ 矩阵是一个“基变换矩阵” (Change of Basis Matrix)。</strong> 它的推导是纯粹的数学。</p>
<p>我们再回到这两个公式：</p>
<ol>
<li>$P(t) = T(t) \cdot A$ (多项式形式， $T(t) = [1, t, t^2, \dots, t^k]$)</li>
<li>$P(t) = N(t) \cdot C$ (B样条形式， $N(t) = [N_{0,k}(t), N_{1,k}(t), \dots]$)</li>
</ol>
<p>我们想找到 $M$ 使得 $A = M \cdot C$。
将 $A$ 替换掉： $P(t) = T(t) \cdot (M \cdot C)$
所以，我们必须找到一个 $M$ 满足：</p>
<p>$$N(t) = T(t) \cdot M$$</p>
<hr>
<h3><span id="%E6%8E%A8%E5%AF%BC%E6%96%B9%E6%B3%95%E6%B3%B0%E5%8B%92%E5%B1%95%E5%BC%80">推导方法：泰勒展开</span></h3>
<p>我们可以通过在 $t=0$ 处对 $P(t)$ <strong>连续求导</strong>来“剥离”出多项式系数 $A_i$。</p>
<p>我们以<strong>三次B样条 (k=3, Order=4)</strong> 为例（比代码中的5次简单，但原理一致）。
$P(t) = A_0 + A_1 t + A_2 t^2 + A_3 t^3$</p>
<p><strong>第1步：求 $A_0$ (M的第一行)</strong></p>
<ul>
<li>在 $t=0$ 处求值：
$P(0) = A_0$</li>
<li>同时，在B样条世界中：
$P(0) = C_0 N_0(0) + C_1 N_1(0) + C_2 N_2(0) + C_3 N_3(0)$</li>
<li>所以：$A_0 = C_0 N_0(0) + C_1 N_1(0) + C_2 N_2(0) + C_3 N_3(0)$</li>
<li><strong>结论</strong>：$M$ 矩阵的<strong>第一行</strong>就是B样条基函数在 $t=0$ 处的值：
$M_{\text{row } 0} = [N_0(0), N_1(0), N_2(0), N_3(0)]$</li>
</ul>
<p><strong>第2步：求 $A_1$ (M的第二行)</strong></p>
<ul>
<li>对 $P(t)$ 求一阶导数：
$P’(t) = A_1 + 2 A_2 t + 3 A_3 t^2$</li>
<li>在 $t=0$ 处求值：
$P’(0) = A_1$</li>
<li>同时，在B样条世界中求导：
$P’(0) = C_0 N’_0(0) + C_1 N’_1(0) + C_2 N’_2(0) + C_3 N’_3(0)$</li>
<li><strong>结论</strong>：$M$ 矩阵的<strong>第二行</strong>就是B样条基函数的一阶导数在 $t=0$ 处的值：
$M_{\text{row } 1} = [N’_0(0), N’_1(0), N’_2(0), N’_3(0)]$</li>
</ul>
<p><strong>第3步：求 $A_2$ (M的第三行)</strong></p>
<ul>
<li>对 $P(t)$ 求二阶导数：
$P’'(t) = 2 A_2 + 6 A_3 t$</li>
<li>在 $t=0$ 处求值：
$P’‘(0) = 2 A_2 \implies A_2 = \frac{P’'(0)}{2}$</li>
<li><strong>结论</strong>：$M$ 矩阵的<strong>第三行</strong>是基函数二阶导数值除以 $2$ (即 $2!$)：
$M_{\text{row } 2} = \frac{1}{2!} [N’‘_0(0), N’‘_1(0), N’‘_2(0), N’'_3(0)]$</li>
</ul>
<p><strong>第4步：求 $A_k$ (M的第k+1行)</strong></p>
<ul>
<li><strong>通用公式（泰勒展开）</strong>：$A_k = \frac{P^{(k)}(0)}{k!}$</li>
<li><strong>M 矩阵的通用定义</strong>： $M$ 矩阵第 $i$ 行、第 $j$ 列的元素 $M(i, j)$ 为：</li>
</ul>
<p>$$M(i, j) = \frac{N_{j,k}^{(i)}(0)}{i!}$$</p>
<p>(即：第 $j$ 个基函数的 $i$ 阶导数在 $t=0$ 处的值，再除以 $i$ 的阶乘)</p>
<h3><span id="cal_m-%E5%87%BD%E6%95%B0%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88"><code>cal_M</code> 函数在做什么？</span></h3>
<p><code>cal_M</code> 函数中的那个复杂的、带有组合数 <code>C_a_b</code> 和 <code>pow</code> 的公式，就是 $M(i, j) = \frac{N_{j,k}^{(i)}(0)}{i!}$ 这个公式的<strong>最终解析解</strong>（Analytic Solution）。</p>
<ul>
<li><code>temp_k</code> 就是 $k$ (次数)。</li>
<li><code>factor</code> 就是 $k!$。</li>
<li><code>temp1</code> 和 <code>temp2</code> 里的组合数和循环，就是数学家们通过符号计算（比如用Mathematica）推导出的 $N_{j,k}^{(i)}(0)$ 的通用表达式。</li>
</ul>
<h1><span id="b%E6%A0%B7%E6%9D%A1%E4%B8%8E%E8%B4%9D%E5%A1%9E%E5%B0%94%E7%9A%84%E8%BD%AC%E6%8D%A2">B样条与贝塞尔的转换</span></h1>
<h3><span id="step-1-%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">Step 1: 需要解决的问题：</span></h3>
<p>一个在路径规划中非常经典的问题：</p>
<p><strong>“我想要B样条的平滑性（Jerk/Snap连续），但又想要贝塞尔曲线的严格约束性（凸包特性）。我如何能两者兼得？”</strong></p>
<p>本架构使用的方案是：<strong>“用B样条的控制点作为优化变量，但在构建约束时，把它们‘假装’成贝塞尔控制点来用。”</strong></p>
<ul>
<li>
<p><strong>B样条控制点（钝器）</strong>：</p>
<ul>
<li><strong>优点</strong>：非常适合做<strong>平滑度</strong>优化。B样条的数学结构保证了曲线在节点处是连续的（C2, C3, C4…连续）。</li>
<li><strong>缺点</strong>：不适合做<strong>边界约束</strong>。B样条的“凸包性”很弱，控制点 $C_i$ 对曲线的影响是“柔和”且“宽泛”的。你把 $C_i$ 放在路沿内侧，并<strong>不能保证</strong>曲线本身不会“鼓出去”撞上路沿。</li>
</ul>
</li>
<li>
<p><strong>贝塞尔控制点（利器）</strong>：</p>
<ul>
<li><strong>优点</strong>：非常适合做<strong>边界约束</strong>。贝塞尔曲线有严格的**“凸包性”（Convex Hull Property）<strong>。只要你保证</strong>所有<strong>贝塞尔控制点 $B_i$ 都在路沿内侧，数学上就</strong>100%保证**整条曲线段都在路沿内侧。</li>
<li><strong>缺点</strong>：不适合做<strong>平滑拼接</strong>。要把很多段贝塞尔曲线平滑地（例如曲率连续）拼在一起，需要对控制点施加额外的、复杂的等式约束，这会把优化问题搞得很复杂。</li>
</ul>
</li>
</ul>
<p><strong>设计决策：</strong>
我们选择B样条控制点 $C$ 作为我们的<strong>最终优化变量 $x$</strong>，因为它们天生就能保证平滑。
但是，在施加边界约束时，我们希望能利用贝塞尔控制点 $B$ 的“凸包性”。</p>
<h3><span id="step-2-%E6%98%8E%E7%A1%AE%E7%9B%AE%E6%A0%87%E5%BB%BA%E7%AB%8B%E7%BA%A6%E6%9D%9F%E7%BF%BB%E8%AF%91">Step 2: 明确目标（建立“约束翻译”）</span></h3>
<p>我们的优化问题是：</p>
<ul>
<li><strong>求解</strong>：$x = C_{\text{B-spline}}$ (B样条控制点)</li>
<li><strong>最小化</strong>：<code>Cost(C)</code> (B样条的Jerk、Snap等平滑成本)</li>
<li><strong>约束</strong>：…</li>
<li>我们<strong>真正想要的约束</strong>是施加在贝塞尔控制点 $B$ 上的：
$\text{Boundary} \cdot B \le \text{Limit}$</li>
<li>但我们的<strong>优化变量</strong>是 $C$。</li>
<li>所以，我们必须找到一个**“翻译矩阵” $M_{\text{trans}}$**，它能告诉我们 $B$ 和 $C$ 之间的关系：
$B = M_{\text{trans}} \cdot C$</li>
<li>一旦找到了 $M_{\text{trans}}$，我们就可以把“愿望”代入，得到一个OSQP能看懂的、关于 $C$ 的新约束：
$(\text{Boundary} \cdot M_{\text{trans}}) \cdot C \le \text{Limit}$</li>
</ul>
<h3><span id="step-3-%E6%8E%A8%E5%AF%BC%E7%BF%BB%E8%AF%91%E7%9F%A9%E9%98%B5-%E4%BD%A0%E9%97%AE%E7%9A%84-a_trans_temp">Step 3: 推导“翻译矩阵” (你问的 <code>A_trans_temp</code>)</span></h3>
<ol>
<li><strong>多项式形式</strong>：$P(t) = T \cdot A$</li>
<li><strong>B样条形式</strong>：$P(t) = T \cdot (M_{\text{B-spline}} \cdot C)$</li>
<li><strong>贝塞尔形式</strong>：$P(t) = T \cdot (M_{\text{Bézier}} \cdot B)$</li>
</ol>
<p>从 (2) 和 (3) 可知：
$M_{\text{Bézier}} \cdot B = M_{\text{B-spline}} \cdot C$</p>
<p>两边左乘 $(M_{\text{Bézier}})^{-1}$：
$B = (M_{\text{Bézier}})^{-1} \cdot M_{\text{B-spline}} \cdot C$</p>
<p><strong>这正是 <code>new_osqp_interface.cc</code> 中这行代码的数学原理：</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Eigen::MatrixXd A_trans_temp = A_bezier_inv * M_bspline;<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><code>M_bspline</code> $\implies$ 就是 $M_{\text{B-spline}}$，即B样条基础矩阵（来自 <code>cal_M</code>）。</li>
<li><code>A_trans_temp</code> $\implies$ <strong>这就是我们的“翻译矩阵” $M_{\text{trans}}$！</strong></li>
</ul>
<ol>
<li>
<p><strong>B样条的“段”由“节点”划分</strong>：
“5米”（<code>length_between_knots_</code>） 是**节点（Knot）<strong>的间距。B样条曲线是由节点划分成</strong>段（Segment）**的。</p>
</li>
<li>
<p><strong>一个“段”由 $k+1$ 个控制点决定</strong>：
代码是 $k=5$ 次（<code>B_spline_order 5</code>）。
这意味着，<strong>任意一个</strong>曲线段（比如节点 $t_i$ 到 $t_{i+1}$ 这一段），它的形状是由<strong>6个</strong>（即 $k+1$）B样条控制点 <strong>共同决定的</strong>。</p>
</li>
</ol>
<p><strong>所以，这个“翻译”是“6个B样条控制点 $\to$ 6个贝塞尔控制点”。</strong></p>
<ul>
<li><code>A_trans_temp</code> 是一个 $6 \times 6$ 的矩阵。</li>
</ul>
<p><strong>输入</strong>：6个B样条控制点 $[C_i, C_{i+1}, \dots, C_{i+5}]$</p>
<p><strong>输出</strong>：6个等效的贝塞尔控制点 $[B_0, B_1, \dots, B_5]$（这6个点定义了<strong>同一段</strong>曲线）</p>
<h4><span id="step-4-%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">Step 4: 完整的设计流程（代码实现）</span></h4>
<p>现在，我们来看 <code>AddAugmentConstraintToAmatrix</code> 或 <code>AutomateCalculateAffineConstraint</code> 这样的函数是如何工作的：</p>
<ol>
<li>
<p><strong>遍历所有曲线“段”</strong>：
代码通过一个循环 <code>for (int i = 1; i &lt; num_of_knots_; i++)</code> 来遍历<strong>每一段</strong>曲线。</p>
</li>
<li>
<p><strong>获取该段的“B样条控制点组”</strong>：
代码知道第 <code>i</code> 段曲线（从节点 <code>i-1</code> 到 <code>i</code>）是由 <code>spline_order_ + 1</code>（即6）个B样条控制点决定的，<strong>这6个控制点的起始索引是 <code>i-1</code></strong>。</p>
</li>
<li>
<p><strong>获取该段的“路沿约束”</strong>：
代码获取第 <code>i</code> 段对应的路沿边界（比如一条直线 $ax+by \le c$）。这个约束用一个矩阵 <code>A_vertice</code> 来表示，它代表 $a$ 和 $b$。</p>
</li>
<li>
<p><strong>执行“约束翻译”</strong>：
我们的“愿望”是：<code>A_vertice * B_seg &lt;= c</code> (其中 $B_{seg}$ 是这一段的6个贝塞尔控制点)</p>
</li>
</ol>
<p>我们的“翻译”是：$B_{seg} = \text{A\\_trans\\_temp} \cdot C_{seg}$ (其中 $C_{seg}$ 是这一段的6个B样条控制点)
代码计算这个“翻译后”的约束矩阵：
<code>Eigen::MatrixXd A_vertice_bound = A_vertice * A_trans;</code>
（这里的 <code>A_trans</code> 就是 <code>A_trans_temp</code>）</p>
<ol>
<li><strong>“喂”给求解器</strong>：
<code>A_vertice_bound</code> 现在是一个（例如） $6 \times 12$ 的矩阵，它代表了对6个B样条控制点（$C_i, \dots, C_{i+5}$）的 $x$ 和 $y$ 坐标施加的等效约束。</li>
</ol>
<p>代码将这个 <code>A_vertice_bound</code> 矩阵，<strong>填充</strong>到OSQP总约束矩阵 $A$ 的<strong>正确位置</strong>——即对应B样条控制点 <code>i-1</code> 到 <code>i+4</code> 的那几列中。
（例如 <code>A_matrix(row_index, k + i - 1) = A_vertice_bound(j, k);</code>）</p>
<h1><span id="%E9%99%84%E5%BD%95">附录</span></h1>
<h2><span id="%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5">转换矩阵</span></h2>
<p>$$A_{trans\\_temp} = (M_{\text{Bézier}})^{-1} * M_{bspline}$$</p>
<p>$$(M_{\text{Bézier}})^{-1} = \begin{bmatrix} 1.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 \\ 1.0 &amp; 0.2 &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; 0.0 \\ 1.0 &amp; 0.4 &amp; 0.1 &amp; 0.0 &amp; 0.0 &amp; 0.0 \\ 1.0 &amp; 0.6 &amp; 0.3 &amp; 0.1 &amp; 0.0 &amp; 0.0 \\ 1.0 &amp; 0.8 &amp; 0.6 &amp; 0.4 &amp; 0.2 &amp; 0.0 \\ 1.0 &amp; 1.0 &amp; 1.0 &amp; 1.0 &amp; 1.0 &amp; 1.0 \end{bmatrix}$$
$$M_{\text{B-spline}} = \frac{1}{120} \begin{bmatrix} 1 &amp; 26 &amp; 66 &amp; 26 &amp; 1 &amp; 0 \\ -5 &amp; -50 &amp; 0 &amp; 50 &amp; 5 &amp; 0 \\ 10 &amp; 20 &amp; -60 &amp; 20 &amp; 10 &amp; 0 \\ -10 &amp; 20 &amp; 60 &amp; -20 &amp; -10 &amp; 0 \\ 5 &amp; -20 &amp; 30 &amp; -20 &amp; 5 &amp; 0 \\ -1 &amp; 5 &amp; -10 &amp; 10 &amp; -5 &amp; 1 \end{bmatrix}$$</p>
<h1><span id="b%E6%A0%B7%E6%9D%A1%E6%A0%B8%E5%BF%83%E8%8A%82%E7%82%B9%E6%8E%A7%E5%88%B6%E7%82%B9%E6%9B%B2%E7%BA%BF%E6%AE%B5%E6%95%B0%E4%B8%8E%E6%AC%A1%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB">B样条核心：节点、控制点、曲线段数与次数的关系</span></h1>
<p>在B样条的数学理论中，节点（Knots）、控制点（Control Points）、**曲线段数（Segments）**和次数（Degree）之间的关系是固定的。</p>
<p>有两个核心公式：</p>
<ol>
<li><strong>经典教科书公式</strong>（关于节点向量<strong>总长度</strong>）：</li>
</ol>
<p>$$m = n + p$$
或者</p>
<p>$$m = n + k + 1$$
* $m$ = <strong>节点(Knots)的数量</strong>（即节点向量的总长度）
* $n$ = <strong>控制点(Control Points)的数量</strong>
* $p$ = <strong>阶数 (Order)</strong>
* $k$ = <strong>次数 (Degree)</strong> (并且 $p = k + 1$)</p>
<ol start="2">
<li><strong>工程“黄金公式”</strong>（关于<strong>曲线段</strong>数量）：</li>
</ol>
<p>$$n = N_{\text{seg}} + k$$
* $N_{\text{seg}}$ = <strong>曲线段(Segments)的数量</strong>
* $n$ = <strong>控制点(Control Points)的数量</strong>
* $k$ = <strong>次数 (Degree)</strong></p>
<p><strong>换算关系：</strong>
我们可以将这两个公式合并，得到所有四个量之间的关系：
$m = (N_{\text{seg}} + k) + k + 1$</p>
<p>$$m = N_{\text{seg}} + 2k + 1$$</p>
<p><strong>举个例子（$k=3$）</strong>：</p>
<ul>
<li>假设我们有 <strong>5段</strong> 曲线 ($N_{\text{seg}}=5$)。</li>
<li>根据公式2，我们需要 $n = 5 + 3 = 8$ 个<strong>控制点</strong>。</li>
<li>根据公式1，节点向量总长度 $m = 8 + 3 + 1 = 12$ 个<strong>节点</strong>。
<ul>
<li>(例如：<code>[0, 0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 5]</code>)</li>
</ul>
</li>
</ul>
<hr>
<h3><span id="%E8%BF%99%E5%A5%97%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9B%B4%E7%9B%B4%E8%A7%82">这套代码中的实现（更直观）</span></h3>
<p>你的这套代码<strong>没有</strong>使用上面的公式，而是用了一个更符合工程直觉的、<strong>等效</strong>的公式。</p>
<p>在 <code>new_osqp_interface.cc</code> 的 <code>Update_refpoint_Bspline</code> 函数中，关系是这样定义的：</p>
<ol>
<li>
<p><strong><code>num_of_knots_</code></strong></p>
<ul>
<li>在代码中，这个变量<strong>不是</strong>指节点向量的总长度。</li>
<li>它指的是你输入的<strong>参考点（Ref Points）的数量</strong>。</li>
<li><code>size_t num_of_knots = resample_points.size();</code></li>
</ul>
</li>
<li>
<p><strong><code>num_of_knots_interval_</code></strong></p>
<ul>
<li>这个变量被定义为 <code>num_of_knots_ - 1</code>。</li>
<li>它的真正含义是**“B样条的曲线段（Segment）的数量”**。</li>
<li>例如：你有10个参考点，你就在它们之间创建 $10-1 = 9$ 段B样条曲线。</li>
</ul>
</li>
<li>
<p><strong><code>spline_order_</code></strong></p>
<ul>
<li>在 <code>B_spline.h</code> 中 <code>B_spline_order</code> 被定义为5。</li>
<li>在 <code>B_spline.cpp</code> 中，<code>M</code> 矩阵被resize为 <code>(a+1, a+1)</code>，其中 <code>a = B_spline_order</code>。</li>
<li>这证明了 <code>spline_order_</code> 变量存储的是<strong>次数 (Degree, k)</strong>，即 $k=5$。</li>
<li>（因此，这是一个 <strong>5次、6阶</strong> 的B样条）。</li>
</ul>
</li>
</ol>
<h4><span id="%E6%A0%B8%E5%BF%83%E5%85%AC%E5%BC%8F%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84">核心公式（代码中的）</span></h4>
<p>在 <code>Update_refpoint_Bspline</code> 中，关键的赋值是：</p>
<p><code>set_num_of_control_points(num_of_knots + spline_order_ - 1);</code></p>
<p>我们来翻译一下这个公式：</p>
<p>$$n = N_{\text{ref}} + k - 1$$</p>
<ul>
<li>$n$ = <code>num_of_control_points_</code></li>
<li>$N_{\text{ref}}$ = <code>num_of_knots_</code> （参考点的数量）</li>
<li>$k$ = <code>spline_order_</code> （次数，为5）</li>
</ul>
<h4><span id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B8%AA%E5%85%AC%E5%BC%8F%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84">为什么这个公式是正确的？</span></h4>
<p>我们把上面这个公式换一种写法。
我们知道 $N_{\text{seg}} = N_{\text{ref}} - 1$，所以 $N_{\text{ref}} = N_{\text{seg}} + 1$。
代入上面的公式：
$n = (N_{\text{seg}} + 1) + k - 1$
$n = N_{\text{seg}} + k$</p>
<p><strong>这正是B样条中关于“分段”的黄金公式：</strong></p>
<blockquote>
<p><strong>控制点的数量 = 曲线段的数量 + 曲线的次数</strong>
<strong>$n = N_{\text{seg}} + k$</strong></p>
</blockquote>
<p><strong>直观理解一下这个公式（以 $k=5$ 为例）：</strong></p>
<ul>
<li><strong>第1段 (N<sub>seg</sub>=1)</strong>：你需要 $k+1$ 个控制点来定义第一段曲线（即6个CPs）。
<ul>
<li>公式：$n = 1 + 5 = 6$。 <strong>(正确)</strong></li>
</ul>
</li>
<li><strong>第2段 (N<sub>seg</sub>=2)</strong>：为了和第一段平滑拼接，你只需要<strong>增加1个新</strong>的控制点。
<ul>
<li>总控制点数 = 7。</li>
<li>公式：$n = 2 + 5 = 7$。 <strong>(正确)</strong></li>
</ul>
</li>
<li><strong>第3段 (N<sub>seg</sub>=3)</strong>：你再<strong>增加1个新</strong>的控制点。
<ul>
<li>总控制点数 = 8。</li>
<li>公式：$n = 3 + 5 = 8$。 <strong>(正确)</strong></li>
</ul>
</li>
</ul>
<p><strong>以此类推…</strong></p>
<p><strong>第 $N_{\text{seg}}$ 段</strong>：你需要 $N_{\text{seg}} + k$ 个控制点。</p>
<h3><span id="%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E8%BF%99%E4%B8%AA%E5%85%B3%E7%B3%BB">代码中如何定义这个关系</span></h3>
<table>
<thead>
<tr>
<th style="text-align:left">理论术语</th>
<th style="text-align:left">代码中的变量</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>参考点数量</strong> ($N_{\text{ref}}$)</td>
<td style="text-align:left"><code>num_of_knots_</code></td>
<td style="text-align:left"><code>resample_points.size()</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>曲线段数量</strong> ($N_{\text{seg}}$)</td>
<td style="text-align:left"><code>num_of_knots_interval_</code></td>
<td style="text-align:left">等于 <code>num_of_knots_ - 1</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>B样条次数</strong> ($k$)</td>
<td style="text-align:left"><code>spline_order_</code></td>
<td style="text-align:left">固定为 5</td>
</tr>
<tr>
<td style="text-align:left"><strong>控制点数量</strong> ($n$)</td>
<td style="text-align:left"><code>num_of_control_points_</code></td>
<td style="text-align:left">由公式 $n = N_{\text{seg}} + k$ 算出</td>
</tr>
</tbody>
</table>
<p>代码中的核心关系在 <code>Update_refpoint_Bspline</code> 中：
<code>num_of_control_points_</code> = (<code>num_of_knots_</code> - 1) + <code>spline_order_</code>
即：
<strong>控制点数量 = (参考点数量 - 1) + 次数</strong></p>
<h1><span id="%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAhessian%E5%92%8C%E7%BA%A6%E6%9D%9F">本项目如何构建hessian和约束</span></h1>
<h2><span id="%E4%BD%8D%E7%BD%AE%E6%88%90%E6%9C%AC">位置成本</span></h2>
<p>$J = w \cdot || P_i - P_{\text{ref}, i} ||^2$</p>
<p>成本函数可简化为：$J \approx w \cdot P_i^T P_i - 2w \cdot P_i^T P_{\text{ref}, i}$</p>
<p>B样条的一个核心特性是，曲线上任何一点的任何属性（位置、速度、加速度…）都可以表示为B样条控制点 $C$ 的线性组合。</p>
<p>$P_i = N_{p, i} \cdot C$
（其中 $N_{p, i}$ 是一个行向量，它来自B样条基础矩阵 Np 的第 $i$ 行，代表了在第 $i$ 个节点上，各个控制点对“位置”的“影响力”权重）</p>
<p>$J \approx w \cdot C^T (N_{p, i}^T N_{p, i}) C - (2w \cdot N_{p, i}^T P_{\text{ref}, i})^T C$</p>
<p>Hessian $P$ 的部分： $P_i = 2 \cdot w \cdot (N_{p, i}^T N_{p, i})$梯度 $q$ 的部分： $q_i = -2w \cdot N_{p, i}^T P_{\text{ref}, i}$</p>
<h2><span id="%E8%88%AA%E5%90%91%E6%88%90%E6%9C%AC-pointcost_v_">航向成本 (PointCost_v_)</span></h2>
<p>成本函数：$J_v = w_v \cdot || V_i - V_{\text{ref}, i} ||^2$B</p>
<p>样条形式：$V_i = N_{v, i} \cdot C$ (其中 $N_{v, i}$ 是 Nv 矩阵的第 $i$ 行)。</p>
<p>Hessian $P$ 的部分：$P_v = 2 \cdot w_v \cdot (N_{v, i}^T N_{v, i})$</p>
<h2><span id="%E5%8A%A0%E9%80%9F%E5%BA%A6%E6%9B%B2%E7%8E%87%E6%88%90%E6%9C%AC-pointcost_a_">加速度/曲率成本 (PointCost_a_)</span></h2>
<p>成本函数：$J_a = w_a \cdot || A_i - A_{\text{ref}, i} ||^2$B</p>
<p>样条形式：$A_i = N_{a, i} \cdot C$ (其中 $N_{a, i}$ 是 Na 矩阵的第 $i$ 行)。</p>
<p>Hessian $P$ 的部分：$P_a = 2 \cdot w_a \cdot (N_{a, i}^T N_{a, i})$</p>
<h2><span id="jerk-%E5%92%8C-snap-%E6%88%90%E6%9C%AC-pointcost_j_-pointcost_s_">Jerk 和 Snap 成本 (PointCost_j_, PointCost_s_)</span></h2>
<p>PointCost_j_：最小化三阶导数（Jerk，加加速度），减少“闯动感”。</p>
<p>PointCost_s_：最小化四阶导数（Snap，加加加速度），减少“抖动感”。</p>
<p>$J_j = w_j \cdot || J_i - 0 ||^2 = w_j \cdot || J_i ||^2$</p>
<h3><span id="%E7%9B%B8%E5%85%B3%E7%9F%A9%E9%98%B5%E7%9A%84%E8%8E%B7%E5%BE%97">相关矩阵的获得</span></h3>
<ol>
<li>
<p>M 矩阵（位置基础矩阵）的获得
$M$ 矩阵（即位置基础矩阵，对应于 0 次导数）是通过一个复杂的解析公式一次性计算出来的。</p>
<p><strong>初始化</strong>：在 B_spline 构造函数中，首先根据样条的阶数（$a=5$，即6阶）来调整矩阵大小：this-&gt;M.resize(a + 1, a + 1);。</p>
<p><strong>计算</strong>：核心的计算逻辑封装在 cal_M(Eigen::MatrixXd &amp;M) 函数中。</p>
<p><strong>推导原理</strong>：cal_M 函数通过多层循环和组合数函数 C_a_b，实现了将B样条定义直接转换到**多项式基（Monomial Basis）**的解析公式。这个公式是事先推导好的，用于快速计算 $M$ 矩阵的每一个元素 $M(i, j)$。 计算方式前文已述。</p>
</li>
<li>
<p>导数矩阵（M<sub>diff_1</sub>, M<sub>diff_2</sub>, …）的获得导数矩阵是通过对已有的 $M$ 矩阵施加 <strong>差分算子（Difference Operator）</strong> 来获得的，而不是重新计算。这个过程利用了B样条的导数特性。</p>
<p><strong>核心原理</strong>：差分矩阵对于B样条，下一阶导数的控制点 $C’$ 与当前阶的控制点 $C$ 之间存在一个线性关系，这个关系可以表示为一个差分矩阵。例如，速度（1次导数）的控制点 $C’$ 是由位置控制点 $C$ 的相邻点相减得到的。</p>
<p><strong>构造差分矩阵</strong>：代码首先构造了一个 $k \times (k+1)$ 的差分矩阵 v_mat（用于1阶导数）。这个矩阵的元素是 [-1, 1] 的对角块形式。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a; i++) {<br>    <span class="hljs-built_in">v_mat</span>(i, i) = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">v_mat</span>(i, i + <span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>$$v_{\text{mat}} = \begin{bmatrix} -1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -1 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 1 \end{bmatrix}$$
应用差分：将差分矩阵乘以原始的基础矩阵，即可得到下一阶的导数基础矩阵：this-&gt;M_diff_1 = this-&gt;M_diff_1 * v_mat;</p>
<ol start="3">
<li>链式应用（2, 3, 4 阶导数）对于更高的阶数（加速度 $M_{\text{diff\\_2}}$、Jerk $M_{\text{diff\\_3}}$、Snap $M_{\text{diff\\_4}}$），代码继续构造新的差分矩阵 (a_mat, jerk_mat, snap_mat)，并以链式法则的形式将它们连续应用到原始的基础矩阵上：
<strong>2阶导数：</strong> this-&gt;M_diff_2 = this-&gt;M_diff_2 * a_mat * v_mat;
<strong>4阶导数：</strong> this-&gt;M_diff_4 = this-&gt;M_diff_4 * snap_mat * jerk_mat * a_mat * v_mat;</li>
</ol>
<h3><span id="b%E6%A0%B7%E6%9D%A1%E7%9A%84%E6%B1%82%E5%AF%BC%E5%92%8C%E5%B7%AE%E5%88%86">B样条的求导和差分</span></h3>
<p>对于一个 $k$ 次B样条，它的第 $r$ 阶导数是一条 $k-r$ 次的B样条。第 $r$ 阶导数的第 $i$ 个控制点 $C^{®}_{i}$ 由以下公式给出：</p>
<p>$$C^{®}_{i} = \frac{k - r + 1}{t_{i+k+1} - t_{i+r}} (C^{(r-1)}_{i+1} - C^{(r-1)}_{i})$$</p>
<p>对于均匀B样条，即我们假设节点间距是恒定的（通常为1）。在这种情况下，上式中的系数项（被称为缩放因子）可以简化为一个常数：</p>
<p>$$\frac{k - r + 1}{t_{i+k+1} - t_{i+r}} \quad \xrightarrow{\text{Uniform Knots}} \quad \frac{k - r + 1}{k - r + 1} = 1$$</p>
<p>我们的目标是构造一个矩阵 $D$ (即 $v_{mat}$, $a_{mat}$, 等)，它能将 $N_{\text{in}}$ 个控制点（输入向量）转换为 $N_{\text{out}}$ 个控制点（输出向量）。假设我们要计算第 $r$ 阶导数，即从 degree $k-r+1$ 降到 $k-r$。</p>
<p>$$D_{r}(i, j) = \begin{cases} -1 &amp; \text{if } j = i \\ +1 &amp; \text{if } j = i+1 \\ 0 &amp; \text{otherwise} \end{cases}$$</p>
<p>要从原始的 $C_{\text{position}}$ 向量直接计算第 $r$ 阶导数 $C^{®}$，我们需要连续应用 $r$ 个差分矩阵。</p>
<p>$$C^{®} = D_{\text{total}} \cdot C_{\text{position}}$$</p>
<p>$D_1$ (即 $v_{\text{mat}}$)：作用于原始 $k$ 次控制点，生成 $k-1$ 次控制点。</p>
<p>$D_2$ (即 $a_{\text{mat}}$)：作用于 $D_1$ 的结果，生成 $k-2$ 次控制点。</p>
<p>$D_r$：作用于第 $r-1$ 阶导数的控制点，生成最终的 $r$ 阶导数控制点。</p>
<p>$v_{\text{mat}}$ ($D_1$)：$5 \times 6$
$a_{\text{mat}}$ ($D_2$)：$4 \times 5$
$jerk_{\text{mat}}$ ($D_3$)：$3 \times 4$
$snap_{\text{mat}}$ ($D_4$)：$2 \times 3$</p>
<h3><span id="n%E7%9F%A9%E9%98%B5%E6%9E%84%E6%88%90">N矩阵构成</span></h3>
<p>以Np为例
对于位置（0次导数），局部构建块是 $1 \times 6$ 的 $row\\_0$ 向量：这个 $row\\_0$ 是从 $6 \times 6$ 的 $M$ 矩阵（位置基础矩阵）中提取出来的。它代表了 $k+1=6$ 个控制点对单个节点位置的影响权重。</p>
<p>通过循环将 $row\\_0$ 堆叠到 $Np$ 中：</p>
<ol>
<li>循环：代码遍历所有节点（for (int row_index = 0; …)），每一行对应曲线上一个要被约束的位置。</li>
<li>稀疏性：由于局部控制性，每一行只在对应影响它的6个控制点（列）上包含非零值（即 $row\\_0$）。</li>
<li>平移：代码计算出当前节点对应的 6个控制点的起始列索引（interval_index），然后将 $row\\_0$ 填充到 $Np$ 矩阵的相应位置。通过这种方式， $Np$ 矩阵被构建成一个带有稀疏对角块的结构，从而实现了全局映射。</li>
</ol>
<h2><span id="%E7%BA%A6%E6%9D%9F%E6%9E%84%E5%BB%BA">约束构建</span></h2>
<table>
<thead>
<tr>
<th style="text-align:left">约束类型</th>
<th style="text-align:left">物理/几何含义</th>
<th style="text-align:left">对应导数阶数</th>
<th style="text-align:left">约束的目标对象</th>
<th style="text-align:left">代码结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>位置 (Position)</strong></td>
<td style="text-align:left">路径必须穿过或接近某一 ($X, Y$) 点。</td>
<td style="text-align:left"><strong>0次导数</strong></td>
<td style="text-align:left">曲线在特定<strong>节点</strong>上的位置 ($P(t_i)$)</td>
<td style="text-align:left"><code>HardPointPosConstraint</code>, <code>SoftPointPosConstraint</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>航向 (Heading)</strong></td>
<td style="text-align:left">曲线必须以某一角度（方向）通过该点。</td>
<td style="text-align:left"><strong>1次导数</strong></td>
<td style="text-align:left">曲线在特定<strong>节点</strong>上的切线向量 ($\frac{dP}{dt}$)</td>
<td style="text-align:left"><code>HardPointConstraint</code>, <code>SoftPointConstraint</code> (用于 <code>v</code>)</td>
</tr>
<tr>
<td style="text-align:left"><strong>曲率 (Curvature)</strong></td>
<td style="text-align:left">曲线在该点的弯曲程度不能超过限制。</td>
<td style="text-align:left"><strong>2次导数</strong></td>
<td style="text-align:left">曲线在特定<strong>节点</strong>上的加速度向量 ($\frac{d^2P}{dt^2}$)</td>
<td style="text-align:left"><code>HardPointConstraint</code>, <code>SoftPointConstraint</code> (用于 <code>a</code>)</td>
</tr>
<tr>
<td style="text-align:left"><strong>线/边界 (Line)</strong></td>
<td style="text-align:left"><strong>整段</strong>曲线必须位于一条直线边界的内侧。</td>
<td style="text-align:left"><strong>几何约束</strong> (通过 Bézier 凸包实现)</td>
<td style="text-align:left">曲线的整个<strong>分段</strong> ($P(t)$ for $t \in [t_i, t_{i+1}]$)</td>
<td style="text-align:left"><code>HardLineConstraint</code>, <code>SoftLineConstraint</code></td>
</tr>
</tbody>
</table>
<h3><span id="%E4%BD%8D%E7%BD%AE%E7%BA%A6%E6%9D%9F">位置约束</span></h3>
<p>我们将位置 $P(t_i)$ 表示为控制点 $C$ 的线性组合：</p>
<p>$$P(t_i) = Np_i \cdot C$$</p>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">X 坐标 (行 $i$)</th>
<th style="text-align:left">Y 坐标 (行 $i+1$)</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>A 矩阵</strong></td>
<td style="text-align:left"><code>Np.row(knot_ind)</code></td>
<td style="text-align:left"><code>Np.row(knot_ind)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>$l$ / $u$ 边界</strong></td>
<td style="text-align:left">$x_{\text{ref}} \pm x_{\text{max/min}}$</td>
<td style="text-align:left">$y_{\text{ref}} \pm y_{\text{max/min}}$</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h3><span id="heading%E7%BA%A6%E6%9D%9F">heading约束</span></h3>
<p>由于QP求解器只能处理线性约束（$Ax \le u$），因此必须将非线性的角度约束 ($\theta = \arctan(V_y/V_x)$) 转化为关于向量分量 ($V_x, V_y$) 的线性不等式。</p>
<p>首先计算出角度边界 ($\theta_{\text{min}}$ 和 $\theta_{\text{max}}$) 对应的 $\cos$ 和 $\sin$ 值：</p>
<p>$\theta_{\text{min}}$ 边界：由 $(dx_{\text{min}}, dy_{\text{min}})$ 定义。</p>
<p>$\theta_{\text{max}}$ 边界：由 $(dx_{\text{max}}, dy_{\text{max}})$ 定义。</p>
<table>
<thead>
<tr>
<th style="text-align:left">约束目的</th>
<th style="text-align:left">数学形式 (线性不等式)</th>
<th style="text-align:left">$A$ 矩阵构建 (Nv 矩阵填充)</th>
<th style="text-align:left">$u$ (上界)</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>下边界 ($\theta \ge \theta_{\text{min}}$)</strong></td>
<td style="text-align:left">$V_x \sin(\theta_{\text{min}}) - V_y \cos(\theta_{\text{min}}) \le 0$</td>
<td style="text-align:left">$Nv \cdot C_x$ (乘 $dy_{\text{min}}$) 和 $Nv \cdot C_y$ (乘 $-dx_{\text{min}}$)</td>
<td style="text-align:left">0</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>上边界 ($\theta \le \theta_{\text{max}}$)</strong></td>
<td style="text-align:left">$V_y \cos(\theta_{\text{max}}) - V_x \sin(\theta_{\text{max}}) \le 0$</td>
<td style="text-align:left">$Nv \cdot C_y$ (乘 $dx_{\text{max}}$) 和 $Nv \cdot C_x$ (乘 $-dy_{\text{max}}$)</td>
<td style="text-align:left">0</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h3><span id="%E6%9B%B2%E7%8E%87%E7%BA%A6%E6%9D%9F">曲率约束</span></h3>
<p>曲率公式：$\kappa = \frac{|V_x A_y - V_y A_x|}{(V_x^2 + V_y^2)^{3/2}}$
($\vec{A}$是二阶导数)
为了在QP求解器中使用，必须将曲率约束简化为一个线性不等式。</p>
<ol>
<li><strong>分母：</strong> 在路径规划的局部优化中，车辆的切线速度（分母项 $V_x^2 + V_y^2$) 被假定为非零常数或已知值。</li>
<li><strong>分子：</strong> 曲率约束被简化为约束分子中的法向加速度分量（即 $V_x A_y - V_y A_x$）。</li>
<li><strong>近似航向：</strong> 为了得到 $V_x$ 和 $V_y$ 的系数，我们用已知的参考航向 $\theta_{\text{ref}}$ （或上一次迭代的航向）来近似 $V_x$ 和 $V_y$：</li>
</ol>
<p>$$V_x \approx \cos(\theta_{\text{ref}})$$
$$V_y \approx \sin(\theta_{\text{ref}})$$</p>
<p>此时约束变为线性的
$$\text{Lower} \le [-\sin(\theta_{\text{ref}}) \cdot A_x + \cos(\theta_{\text{ref}}) \cdot A_y] \le \text{Upper}$$</p>
<table>
<thead>
<tr>
<th style="text-align:left">约束目的</th>
<th style="text-align:left">数学形式 (A x)</th>
<th style="text-align:left">$A$ 矩阵构建</th>
<th style="text-align:left">$l$ / $u$ 边界</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>法向分量 ($A_x$ 贡献)</strong></td>
<td style="text-align:left">$\ddot{x}$ 乘以 $-\sin(\theta_{\text{ref}})$</td>
<td style="text-align:left">$Na \cdot C_x$ (乘以 $-dy$)</td>
<td style="text-align:left">$\kappa_{\text{ref}} \pm \kappa_{\text{max}}$ (乘以 $V^{3/2}$ 缩放)</td>
</tr>
<tr>
<td style="text-align:left"><strong>法向分量 ($A_y$ 贡献)</strong></td>
<td style="text-align:left">$\ddot{y}$ 乘以 $+\cos(\theta_{\text{ref}})$</td>
<td style="text-align:left">$Na \cdot C_y$ (乘以 $+dx$)</td>
<td style="text-align:left">$\kappa_{\text{ref}} \pm \kappa_{\text{max}}$ (乘以 $V^{3/2}$ 缩放)</td>
</tr>
</tbody>
</table>
<!-- hexo injector body_end start -->
<!-- Mermaid Scripts -->
<script>
// 检查页面是否包含Mermaid内容
const hasMermaid = document.querySelector('.mermaid') !== null;

// 如果存在Mermaid图表，则加载Mermaid库
if (hasMermaid) {
  // 加载Mermaid库
  const mermaidScript = document.createElement('script');
  mermaidScript.src = 'https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js';
  mermaidScript.onload = function() {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'default',
      securityLevel: 'loose',
      fontFamily: 'inherit'
    });

    // 重新渲染Mermaid图表
    mermaid.init(undefined, '.mermaid');
  };
  document.head.appendChild(mermaidScript);
}
</script><!-- hexo injector body_end end --></body></html>
	</article>

	 
    <div class="kira-post-copyright">
        <strong>本文作者：</strong>战斗包子<br>
        <strong>本文链接：</strong><a href="https://paipai121.github.io/2025/11/02/%E5%B7%A5%E4%BD%9C/B%E6%A0%B7%E6%9D%A1/" title="https:&#x2F;&#x2F;paipai121.github.io&#x2F;2025&#x2F;11&#x2F;02&#x2F;工作&#x2F;B样条&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;paipai121.github.io&#x2F;2025&#x2F;11&#x2F;02&#x2F;工作&#x2F;B样条&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			                  
			<!-- 先找到与当前文字相同的目录 -->
			                                             
			<!-- 在找到当前文章所在的 index -->
			                                                        
			<!-- 上一篇文章 -->
			<div class="old">
				<span>上一章</span>
				<a href="/2025/11/02/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%97%A5%E5%B8%B8bug%E8%A7%A3%E5%86%B3/"> 日常bug解决</a>
			</div>
			       
			<!-- 下一篇文章 -->
			<div class="new">
				<span>下一章</span>
				<a href="/2025/11/03/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/coding/CodingLearning/"> CodingLearning</a>
			</div>
			                               
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
			<a class="kirafont icon-container-fill -link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a>
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/" rel="tag">技术学习</a>
		
	</div>
	
	<div class="kira-post-footer">
		

		
	<div class="giscus"></div>
  
    <script src="https://giscus.app/client.js"
      data-repo="PaiPai121/discuss"
      data-repo-id="R_kgDOMFuZdw"
      data-category="Announcements"
      data-category-id="DIC_kwDOMFuZd84Cf5yz"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="preferred_color_scheme"
      data-lang="zh-CN"
      data-loading="lazy"
      crossorigin="anonymous"
      async  
    ></script>
  

	</div>
	
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>

		</div>
	</body>
</html>
