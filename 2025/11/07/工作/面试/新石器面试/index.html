<!DOCTYPE html>
<html 
	lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> 一个l4公司的面试 -  KK空间</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="/image/fa.jpeg"
			type="image/jpeg"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<!-- hexo injector head_end start -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$']],
          displayMath: [['$$', '$$']],
          processEscapes: true
        }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
    <!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>

	<body>
		<div
			class="kira-background"
			style="background-image: url('/image/frieren.png')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="KK空间">
        <img
			src="/image/chongye.png"
			alt="战斗包子"
		/>
    </a>
</div>
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a href="/image/chongye.png" title="战斗包子">
			<img
				src="/image/chongye.png"
				alt="战斗包子"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>124</div>
		<div><span>标签</span>24</div>
		<div><span>分类</span>0</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/"
			title="回到首页"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				回到首页
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive.html"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about.html"
			title="关于本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				关于本人
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/friends.html"
			title="我的朋友"
		>
			<i
				class="kirafont
					
						icon-team
					"
			></i>
			<div class="kira-list-item-content">
				我的朋友
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/todolist.html"
			title="我的Todo"
		>
			<i
				class="kirafont
					
						icon-container-fill
					"
			></i>
			<div class="kira-list-item-content">
				我的Todo
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/liferecords"
			title="玩了什么"
		>
			<i
				class="kirafont
					
						icon-fullscreen
					"
			></i>
			<div class="kira-list-item-content">
				玩了什么
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/game_graph.html"
			title="小图"
		>
			<i
				class="kirafont
					
						icon-fullscreen
					"
			></i>
			<div class="kira-list-item-content">
				小图
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=1040035659&website=www.oicqzone.com"
				target="_blank"
				mdui-tooltip="{content: 'QQ'}"
				style="color: rgb(49, 174, 255); background-color: rgba(49, 174, 255, .1);"
			>
				<i
					class="kirafont
					
						icon-QQ
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://space.bilibili.com/6456506"
				target="_blank"
				mdui-tooltip="{content: '哔哩哔哩'}"
				style="color: rgb(231, 106, 141); background-color: rgba(231, 106, 141, .15);"
			>
				<i
					class="kirafont
					
						icon-bilibili
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/PaiPai121/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://gitee.com/<你的gitee id>"
				target="_blank"
				mdui-tooltip="{content: 'Gitee'}"
				style="color: rgb(165, 15, 15); background-color: rgba(165, 15, 15, .15);"
			>
				<i
					class="kirafont
					
						icon-gitee
					"
				></i>
			</a>
		
	</div>
</div>

		
			
		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/AI/" style="font-size: 11.11px;">AI</a> <a href="/tags/GameExtend/" style="font-size: 14.44px;">GameExtend</a> <a href="/tags/MMD/" style="font-size: 11.11px;">MMD</a> <a href="/tags/flash/" style="font-size: 11.11px;">flash</a> <a href="/tags/gaea%E6%A1%86%E6%9E%B6/" style="font-size: 13.33px;">gaea框架</a> <a href="/tags/travel/" style="font-size: 10px;">travel</a> <a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/" style="font-size: 18.89px;">公众号</a> <a href="/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" style="font-size: 11.11px;">凸优化</a> <a href="/tags/%E5%A6%99%E7%93%A6%E5%BA%95/" style="font-size: 10px;">妙瓦底</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 20px;">学习</a> <a href="/tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 10px;">工作</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 12.22px;">开发</a> <a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 12.22px;">强化学习</a> <a href="/tags/%E6%80%80%E6%97%A7/" style="font-size: 11.11px;">怀旧</a> <a href="/tags/%E6%88%91%E7%9A%84%E8%AE%BA%E6%96%87/" style="font-size: 10px;">我的论文</a> <a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 17.78px;">日常</a> <a href="/tags/%E6%9C%AC%E5%9C%B0%E5%AD%98%E6%A1%A3/" style="font-size: 18.89px;">本地存档</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E6%9D%82%E8%B0%88/" style="font-size: 16.67px;">游戏杂谈</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E8%A1%8D%E7%94%9F/" style="font-size: 10px;">游戏衍生</a> <a href="/tags/%E7%9C%8B%E7%95%AA/" style="font-size: 11.11px;">看番</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" style="font-size: 11.11px;">编程基本知识</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" style="font-size: 10px;">自动驾驶</a> <a href="/tags/%E8%8D%89%E5%B1%A5%E8%99%AB%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF/" style="font-size: 11.11px;">草履虫的端到端</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15.56px;">面试</a>
		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			文章归档
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/">2026</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/">2025</a><span class="archive-list-count">62</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">13</span></li></ul>
		</div>
	</div>


		
	</aside>
	<div class="kira-copyright">
		&copy; 2026
		<a href="/">战斗包子</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		
	</div>
</div>
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div
			class="kira-post-cover"
			style="padding-bottom: '56.25%'"
		>
			<img
				data-src="/image/frieren.png"
				data-sizes="auto"
				alt="一个l4公司的面试"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>一个l4公司的面试</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2025年11月07日</a>
			<a><i class="kirafont icon-edit-fill"></i>5.1k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 22 分钟</a>
		</div>
		<html><head></head><body><h1><span id="%E4%B8%80%E9%9D%A2">一面</span></h1>
<p>讨论了自动驾驶参考线规划相关技术，包括换道方式、参考线生成、路径规划等内容，还进行了技术面试考查，具体如下：</p>
<h2><span id="%F0%9F%9A%97-%E5%8F%82%E8%80%83%E7%BA%BF%E4%B8%8E%E6%8D%A2%E9%81%93%E6%8A%80%E6%9C%AF">🚗 参考线与换道技术</span></h2>
<ul>
<li><strong>基础框架：</strong> 系统框架从阿波罗（Apollo）魔改而来，有基础版本。</li>
<li><strong>换道方式：</strong>
<ul>
<li>原平行换道方式：换道距离长，路口连续换道困难。</li>
<li>新参考线直连方式：无 heading 回正过程，用贝塞尔曲线连接，拉长时距保证舒适性。</li>
<li>失败处理：实在换不过去只能去下一个路口掉头。</li>
</ul>
</li>
<li><strong>参考线生成：</strong>
<ul>
<li>有多种参考线，并行会生成自车所在车道、相邻车道及去目标车道参考线。</li>
<li>规划方式分纯平车道和拼接场景两种。</li>
<li>范围与自车位置及感知末端、地图引导点有关。</li>
</ul>
</li>
<li><strong>平滑处理：</strong>
<ul>
<li>用贝塞尔连出点链，放进平滑器优化成一条曲线。</li>
<li>若无动态障碍物，该曲线直接作为控车轨迹。</li>
<li>若有动态障碍物，在此基础上再做处理。</li>
</ul>
</li>
</ul>
<h2><span id="%F0%9F%97%BA%EF%B8%8F-%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E4%B8%8E%E5%86%B3%E7%AD%96">🗺️ 路径规划与决策</span></h2>
<ul>
<li><strong>规划流程：</strong> 后续会进行决策（包括绕行、换道等），规划横向轨迹，再在其上做纵向决策（公共控制和解耦）。</li>
<li><strong>绕行决策：</strong>
<ul>
<li>在参考线下游的路径决策层进行。</li>
<li>将障碍物 bounding box 投影到弗林纳（Frenet）坐标系。</li>
<li>根据其位置和侵入程度决策绕行方向和设置约束，用软约束建模到 QP。</li>
</ul>
</li>
<li><strong>软约束建模：</strong> 加松弛变量，在 Hession 上增广义维，松弛变量大小为软约束权重。满足约束时松弛变量为 0，不满足时在目标函数上加惩罚。</li>
</ul>
<h2><span id="%F0%9F%9A%A6-%E5%A4%9A%E6%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%8D%A2%E9%81%93%E5%86%B3%E7%AD%96">🚦 多态上下文与换道决策</span></h2>
<ul>
<li><strong>参考线生成：</strong> 参考线一直生成，与换道不反馈。</li>
<li><strong>换道执行：</strong> 换道时按 target 参考线直接换，换道前进行校验。</li>
<li><strong>换道校验：</strong> 校验车道有无、目标几秒内有无障碍物、目标车道前后车之间空间是否足够，通过后生成轨迹。</li>
</ul>
<blockquote>
<p>面试官非常了解 Apollo 的框架，因此讲解的基于 Apollo 框架的内容都不感兴趣。</p>
</blockquote>
<h2><span id="%F0%9F%92%BB-%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E8%80%83%E6%9F%A5">💻 技术面试考查</span></h2>
<h3><span id="%E8%AE%B0%E4%BA%8B%E6%9C%AC-coding">记事本 Coding</span></h3>
<ol>
<li>实现一个父类 <code>parent</code>。</li>
<li>父类要有一个虚函数，由子类实现。</li>
<li>在父类实现一个成员，这个成员子类可以访问。</li>
</ol>
<!-- 4.  在子类实现一个静态函数，并调用。 -->
<ol start="5">
<li>实现一个二叉树节点。</li>
<li>以非递归的方式遍历二叉树。</li>
</ol>
<h3><span id="c-%E5%9F%BA%E7%A1%80">C++ 基础</span></h3>
<ol>
<li>什么是前序遍历？</li>
<li>以左中右的顺序遍历二叉树（即中序遍历）。</li>
</ol>
<!-- 3.  什么时候要手动写拷贝构造函数？ -->
<ol start="4">
<li>讲解什么是 <code>shared_ptr</code>，什么是 <code>weak_ptr</code>。</li>
<li>什么是 <code>unordered_map</code>？</li>
<li></li>
</ol>
<!-- 
# 附录：C++ 何时需要手动编写拷贝构造函数？

## 核心答案：当类需要手动管理资源时

最常见的情况就是：**类中包含了裸指针（raw pointer），并且这个类负责管理该指针所指向的内存**（例如，在构造函数中 `new` 分配内存，在析构函数中 `delete` 释放内存）。

---

## 为什么默认拷贝构造函数不行？

### 1. 默认行为：“浅拷贝” (Shallow Copy)

* 如果你不写，C++编译器会为你生成一个默认的拷贝构造函数。
* 它的工作是**逐个复制成员变量**。
* 当成员变量是指针时，它**只会复制指针的地址**，而不会复制指针所指向的数据内容。

### 2. “浅拷贝”引发的问题

浅拷贝导致两个对象（原对象和新拷贝的对象）内部的指针指向**同一块内存**，这会引发严重错误：

* **重复释放 (Double Free):**
    * 当第一个对象被销毁时，其析构函数会 `delete` 掉这块内存。
    * 当第二个对象被销毁时，它会尝试 `delete` **同一块已经被释放的内存**，导致程序崩溃。
* **数据污染:**
    * 两个对象共享同一份数据。
    * 通过一个对象修改数据，会“意外地”影响到另一个对象，破坏了对象的独立性。

---

## 解决方案：“深拷贝” (Deep Copy)

为了解决这个问题，我们必须**手动编写拷贝构造函数**，在其中执行“深拷贝”：

1.  **分配新资源：** 在新对象的构造函数中，为新对象的指针 `new` 一块**新的**内存空间。
2.  **复制内容：** 将原对象指针所指向内存中的**数据内容**，完整地复制到这块新内存中。

这样，两个对象就各自拥有了独立的内存资源，可以安全地各自释放，互不干扰。

---

## 关键概念：“三/五法则” (The Rule of Three/Five)

这个问题的背后是C++著名的“三/五法则”：

* **三法则 (Rule of Three):**
    如果你需要手动实现**析构函数**、**拷贝构造函数**、**拷贝赋值运算符**中的任意一个，那么你很可能需要实现所有这三个。
* **五法则 (Rule of Five):**
    在C++11及以后，这套法则扩展到了五个，增加了**移动构造函数**和**移动赋值运算符**。

根本原因都是一样的：这个类在**手动管理资源**。

---

## 现代C++最佳实践：“零法则” (The Rule of Zero)

在现代C++（C++11及以后）中，我们应该**尽量避免**这种情况，遵循“零法则” (The Rule of Zero)。

* **核心思想：** 使用 **RAII**（资源获取即初始化）原则。
* **具体实践：**
    * 不直接使用裸指针管理内存。
    * 优先使用**智能指针**（如 `std::unique_ptr`, `std::shared_ptr`）来管理动态内存。
    * 使用标准库容器（如 `std::vector`, `std::string`）来管理数据集合。
* **好处：**
    这些智能指针和容器类**本身已经正确地实现了深拷贝、移动或禁止拷贝**的逻辑。当它们作为成员变量时，编译器自动生成的默认拷贝（或移动）构造函数会调用这些成员的对应函数，自动就能完成正确的资源管理，你**无需手动编写**任何资源管理函数。 -->
<h1><span id="%E4%BA%8C%E9%9D%A2">二面</span></h1>
<p>我还以为一面寄了，竟然今天和我约二面了！</p>
<p>以下是豆包总结</p>
<h2><span id="%E4%B8%80%E4%BC%9A%E8%AE%AE%E6%A0%B8%E5%BF%83%E4%BF%A1%E6%81%AF">一、会议核心信息</span></h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>会议主题</td>
<td>CX835城市领航辅助驾驶项目横向规划算法工作汇报与技术面试</td>
</tr>
<tr>
<td>参会人员</td>
<td>汇报人（说话人A）、面试官（说话人B）</td>
</tr>
<tr>
<td>会议时长</td>
<td>约40分钟</td>
</tr>
<tr>
<td>核心聚焦</td>
<td>横向规划算法（参考线生成、车道选择、轨迹优化等）的设计、实现与技术优化</td>
</tr>
</tbody>
</table>
<h2><span id="%E4%BA%8C%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%88%90%E6%9E%9C">二、核心工作成果</span></h2>
<ol>
<li>完成CX835项目横向规划算法核心模块开发，重点突破参考线生成技术，适配平车道、非结构化道路、疑难场景等多类工况。</li>
<li>提出轻地图与感知匹配的多版本迭代方案，解决非结构化道路参考线引导偏差问题，减少撞路沿、驶入对向车道等风险。</li>
<li>设计多状态机切换逻辑，实现平车道、入口、远端感知车道引导等状态的平滑过渡，保障路口通行稳定性。</li>
<li>构建动态障碍物绕行模块与LEDA异常情况处理模块，提升算法对复杂交通环境的适应性。</li>
<li>基于QP优化实现轨迹精调，通过硬约束+软约束结合的方式，平衡轨迹安全性与平滑性。</li>
</ol>
<h2><span id="%E4%B8%89%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E4%BA%AE%E7%82%B9">三、关键技术亮点</span></h2>
<ol>
<li><strong>多场景参考线生成</strong>：平车道采用中心线平滑方案，非结构化道路采用三段式拼接（历史参考线+贝塞尔曲线+目标车道中心线），疑难场景采用专家轨迹模式。</li>
<li><strong>轻地图与感知融合</strong>：迭代路沿匹配、道线宽度修正、对向停止线辅助三类方案，弥补轻地图精度不足的缺陷。</li>
<li><strong>状态机智能切换</strong>：基于地图标识与感知结果，实现多状态自动切换，提前衔接目标车道，避免近端轨迹摆动。</li>
<li><strong>横纵解耦+动态补全</strong>：参考线聚焦静态规划，通过下游绕行模块处理动态障碍物，兼顾规划效率与环境适应性。</li>
</ol>
<h2><span id="%E5%9B%9B%E9%9D%A2%E8%AF%95%E5%AE%98%E6%A0%B8%E5%BF%83%E5%BB%BA%E8%AE%AE">四、面试官核心建议</span></h2>
<ol>
<li><strong>表达优化</strong>：压缩自我介绍篇幅，突出核心成果，后续再展开细节讨论。</li>
<li><strong>成果量化</strong>：补充算法优化的具体指标与数据（如横向偏差降低幅度、场景适配成功率等），增强成果说服力。</li>
<li><strong>技术深化</strong>：
<ul>
<li>明确“画龙”“猛打方向”等问题的量化标准，结合方向盘转速、横向加加速度等物理量，通过数据埋点、影子模式构建闭环优化体系。</li>
<li>参考阿波罗框架中曲率约束的二阶差分项实现，完善轨迹优化的动力学约束设计。</li>
</ul>
</li>
<li><strong>数据驱动</strong>：针对路口等依赖地图的场景，探索数据驱动补全方案，提升算法对地图偏差的容错性。</li>
</ol>
<h2><span id="%E4%BA%94coding">五、coding</span></h2>
<p>计算几何，判断一个点是否在多边形内，应该用射线法
但是我理解成了判断在凸多边形内，只判断了左右。</p>
<h3><span id="%E6%AD%A3%E7%A1%AEcoding%E6%96%B9%E6%B3%95%E4%B8%8E%E6%80%9D%E8%B7%AF">正确coding方法与思路</span></h3>
<h3><span id="%E5%B0%84%E7%BA%BF%E6%B3%95%E7%9A%84%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86">射线法的解析原理</span></h3>
<p>射线法，也称为奇偶规则（Even-Odd Rule）或交叉数法，是判断点是否在多边形内部最常用、最直观的方法。</p>
<h4><span id="1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E5%A5%87%E5%81%B6%E8%A7%84%E5%88%99">1. 核心思想：奇偶规则</span></h4>
<p>其核心思想基于一个简单（但在数学上由“约当曲线定理”保证）的拓扑学事实：</p>
<blockquote>
<p>从平面上的任意一点出发，画一条无限长的射线。如果该点在多边形（一个简单的闭合曲线）的<strong>内部</strong>，那么这条射线穿过（相交于）多边形边界的次数必定为<strong>奇数</strong>。</p>
<p>如果该点在多边形的<strong>外部</strong>，则射线穿过边界的次数必定为<strong>偶数</strong>（包括 0 次）。</p>
</blockquote>
<p><strong>一个简单的比喻：</strong>
想象多边形是一个围栏。</p>
<ul>
<li>如果你仍在围栏<strong>内部</strong>，你向任意方向直线行走，要想到达围栏外（无限远处），你必须<strong>穿过围栏 1 次</strong>（奇数）。</li>
<li>如果你仍在围栏<strong>外部</strong>，你要么根本不会穿过围栏（0 次，偶数），要么你穿进去了（第 1 次），就必须再穿出来（第 2 次）才能到达无限远处。所以你总会穿过 0、2、4… 次（偶数）。</li>
</ul>
<h4><span id="2-%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%B0%84%E7%BA%BF">2. 算法实现：水平射线</span></h4>
<p>为了简化计算，我们通常选择一条<strong>水平向右</strong>的射线。</p>
<p>给定一个点 <code>P(x, y)</code> 和一个多边形（由顶点 <code>V1, V2, ... Vn</code> 组成）：</p>
<ol>
<li><strong>初始化</strong>一个交叉计数器 <code>crossings = 0</code>。</li>
<li><strong>发射射线</strong>：从点 <code>P</code> 出发，画一条 <code>y</code> 值不变、<code>x</code> 向正无穷大（向右）的射线。</li>
<li><strong>遍历多边形的每一条边</strong>：对于从 <code>Vi</code> 到 <code>Vi+1</code> 的每条边：
<ul>
<li>检查这条边是否与我们的水平射线相交。</li>
</ul>
</li>
<li><strong>统计交叉</strong>：如果相交，<code>crossings</code> 加 1。</li>
<li><strong>判断结果</strong>：遍历完所有边后，检查 <code>crossings</code> 的奇偶性。
<ul>
<li><code>crossings % 2 == 1</code> (奇数) $\rightarrow$ 点在多边形<strong>内部</strong>。</li>
<li><code>crossings % 2 == 0</code> (偶数) $\rightarrow$ 点在多边形<strong>外部</strong>。</li>
</ul>
</li>
</ol>
<h4><span id="3-%E5%85%B3%E9%94%AE%E5%A4%84%E7%90%86%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5">3. 关键：处理特殊情况（边界情况）</span></h4>
<p>简单地“计算交叉”在实践中是不可靠的，因为射线可能会“擦过”顶点或与水平边重合。一个健壮的算法必须精确定义什么是“有效交叉”：</p>
<ol>
<li>
<p><strong>射线与水平边重合</strong>：</p>
<ul>
<li><strong>问题</strong>：如果点 <code>P</code> 的 <code>y</code> 坐标与多边形某条水平边的 <code>y</code> 坐标相同，射线可能与这条边重合，产生无限个交点。</li>
<li><strong>解决方案</strong>：<strong>忽略所有水平边</strong>。水平边不构成“穿越”，它们不会使点从“内”变“外”。</li>
</ul>
</li>
<li>
<p><strong>射线穿过顶点</strong>：</p>
<ul>
<li><strong>问题</strong>：如果射线恰好穿过一个顶点，它会同时与两条边（共享该顶点的边）接触。这可能导致被计数两次（偶数）或零次（偶数），即使它只是一次“穿越”。</li>
<li><strong>解决方案</strong>：我们必须制定一个一致的规则来计算顶点。一个非常标准且稳健的规则是：
<ul>
<li><strong>只计算</strong>那些端点 <code>y</code> 坐标<strong>跨越</strong>了射线 <code>y</code> 坐标的边。</li>
<li>对于恰好落在射线上的顶点，我们将其视为属于某一条边。一个常见的约定是：<strong>只计算</strong>其 <code>y</code> 坐标<strong>大于</strong>射线 <code>y</code> 坐标的那个端点（即，只把顶点当作其所在边的“上端点”时才计算）。</li>
<li><strong>一个更简单的实现</strong>是：当一条边的两个端点一个<code>y</code>值 <code>&gt; p.y</code> 而另一个<code>y</code>值 <code>&lt;= p.y</code> 时，我们才认为它可能与射线相交。这自动处理了顶点问题：
<ul>
<li>如果射线穿过一个“凸”顶点（两条边都在射线同一侧），两条边都<strong>不</strong>会满足 <code>(y1 &gt; p.y)</code> 和 <code>(y2 &lt;= p.y)</code> 的组合，所以不计数。</li>
<li>如果射线穿过一个“凹”顶点（两条边在射线两侧），只有一条边（向上跨越的或向下跨越的）会被计算，这是正确的。</li>
<li>如果射线与一个顶点相切（<code>p.y == vi.y</code>），该顶点会被视为其所在边的“下端点”，也只会被计算一次。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 定义点的结构体，并重载运算符</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> {<br>    <span class="hljs-type">double</span> x, y;<br>    <span class="hljs-comment">// 构造函数（可选，但很方便）</span><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> y = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) {}<br>    <span class="hljs-comment">// 重载减法运算符 (P1 - P2)</span><br>    <span class="hljs-comment">// 用于获取从 P2 指向 P1 的向量</span><br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point&amp; other) <span class="hljs-type">const</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x - other.x, y - other.y);<br>    }<br>    <span class="hljs-comment">// 重载加法运算符 (P1 + V1)</span><br>    <span class="hljs-comment">// 用于将一个点按向量 V1 进行平移</span><br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point&amp; other) <span class="hljs-type">const</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x + other.x, y + other.y);<br>    }<br>};<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 使用射线法（水平）判断点是否在多边形内部</span><br><span class="hljs-comment"> * @param polygon 多边形的顶点（必须按顺序排列）</span><br><span class="hljs-comment"> * @param p       要测试的点</span><br><span class="hljs-comment"> * @return true 如果点在内部, false 如果点在外部或边上</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;Point&gt;&amp; polygon, Point p)</span> </span>{<br>    <span class="hljs-type">int</span> n = polygon.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不是一个有效的多边形</span><br>    }<br>    <span class="hljs-type">bool</span> inside = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 遍历多边形的每一条边 (i, j)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>; i &lt; n; j = i++) {<br>        Point p1 = polygon[i];<br>        Point p2 = polygon[j];<br>        <span class="hljs-comment">// 1. 检查Y坐标是否跨越了射线的Y坐标</span><br>        <span class="hljs-keyword">if</span> ( ((p1.y &gt; p.y) != (p2.y &gt; p.y)) ) {<br>            <span class="hljs-comment">// 2. 计算射线与边的交点的 x 坐标</span><br>            <span class="hljs-comment">// (x - p1.x) / (p2.x - p1.x) = (p.y - p1.y) / (p2.y - p1.y)</span><br>            <span class="hljs-comment">// (p2.x - p1.x) 是向量 p1-&gt;p2 的 x 分量</span><br>            <span class="hljs-comment">// (p2.y - p1.y) 是向量 p1-&gt;p2 的 y 分量</span><br>            <span class="hljs-comment">// 尽管我们重载了运算符，但在这里直接使用 x, y 分量进行</span><br>            <span class="hljs-comment">// 斜率和比例计算仍然是最清晰的。</span><br>            <span class="hljs-type">double</span> intersectX = (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x;<br>            <span class="hljs-comment">// 3. 检查交点是否在射线上（即在点的右侧）</span><br>            <span class="hljs-keyword">if</span> (p.x &lt; intersectX) {<br>                inside = !inside; <span class="hljs-comment">// 翻转奇偶性</span><br>            }<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> inside;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-comment">// 使用新的构造函数初始化</span><br>    <span class="hljs-comment">// 矩形 (0,0) -&gt; (5,0) -&gt; (5,5) -&gt; (0,5)</span><br>    std::vector&lt;Point&gt; polygon = {{<span class="hljs-number">0</span>, <span class="hljs-number">0</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">0</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">5</span>}, {<span class="hljs-number">0</span>, <span class="hljs-number">5</span>}};<br><br>    <span class="hljs-comment">// 凹多边形</span><br>    std::vector&lt;Point&gt; concave_polygon = {<br>        {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">0</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">3</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">3</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">0</span>, <span class="hljs-number">3</span>}<br>    };<br><br>    <span class="hljs-comment">// --- 测试运算符重载 ---</span><br>    <span class="hljs-function">Point <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">1.0</span>)</span></span>;<br>    Point diff = v1 - v2; <span class="hljs-comment">// diff 将是 (-2.0, 1.0)</span><br>    std::cout &lt;&lt; <span class="hljs-string">"--- 运算符重载测试 ---"</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"v1 - v2 = ("</span> &lt;&lt; diff.x &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; diff.y &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"------------------------\n"</span> &lt;&lt; std::endl;<br><br><br>    <span class="hljs-comment">// --- 测试点 ---</span><br>    <span class="hljs-function">Point <span class="hljs-title">p_inside</span><span class="hljs-params">(<span class="hljs-number">2.5</span>, <span class="hljs-number">2.5</span>)</span></span>;  <br>    <span class="hljs-function">Point <span class="hljs-title">p_outside</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>)</span></span>; <br>    <span class="hljs-function">Point <span class="hljs-title">p_on_edge</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">2.5</span>)</span></span>;   <br>    <span class="hljs-function">Point <span class="hljs-title">p_on_vertex</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)</span></span>;   <br>    <span class="hljs-function">Point <span class="hljs-title">p_concave_in</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;  <br>    <span class="hljs-function">Point <span class="hljs-title">p_concave_out</span><span class="hljs-params">(<span class="hljs-number">2.5</span>, <span class="hljs-number">2.5</span>)</span></span>; <br><br>    std::cout &lt;&lt; std::boolalpha;<br><br>    std::cout &lt;&lt; <span class="hljs-string">"--- 矩形测试 ---"</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"点 (2.5, 2.5) 在内部吗? "</span> &lt;&lt; <span class="hljs-built_in">isInside</span>(polygon, p_inside) &lt;&lt; std::endl;  <br>    std::cout &lt;&lt; <span class="hljs-string">"点 (10, 2.5) 在内部吗? "</span> &lt;&lt; <span class="hljs-built_in">isInside</span>(polygon, p_outside) &lt;&lt; std::endl; <br>    std::cout &lt;&lt; <span class="hljs-string">"点 (5, 2.5) 在内部吗? "</span> &lt;&lt; <span class="hljs-built_in">isInside</span>(polygon, p_on_edge) &lt;&lt; std::endl;   <br>    std::cout &lt;&lt; <span class="hljs-string">"点 (5, 5) 在内部吗? "</span> &lt;&lt; <span class="hljs-built_in">isInside</span>(polygon, p_on_vertex) &lt;&lt; std::endl; <br><br>    std::cout &lt;&lt; <span class="hljs-string">"\n--- 凹多边形测试 ---"</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">"点 (1, 1) 在内部吗? "</span> &lt;&lt; <span class="hljs-built_in">isInside</span>(concave_polygon, p_concave_in) &lt;&lt; std::endl; <br>    std::cout &lt;&lt; <span class="hljs-string">"点 (2.5, 2.5) 在内部吗? "</span> &lt;&lt; <span class="hljs-built_in">isInside</span>(concave_polygon, p_concave_out) &lt;&lt; std::endl; <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>然后代码习惯需要注意，不修改的量应该传入常量引用。</p>
<h1><span id="%E4%B8%89%E9%9D%A2">三面</span></h1>
<p>这是一场关于求职的技术面试会议。本次会议主要围绕候选人的工作经历、技术能力以及对新工作的期望展开讨论。面试官评估了候选人的编程技能和对自动驾驶规划算法的理解，并介绍了团队的技术方向和工作内容。</p>
<p>1、面试者背景介绍
面试者于2024年7月毕业后加入经纬恒润，担任CX 835项目中的算法工程师，主要负责横向规划模块中的参考线生成部分。
参考线是整套框架的基石，基于定位模块、导航地图和感知车道线信息生成，优化后形成平滑的参考线。
2、离职原因及求职期望
离职原因包括项目已交付，缺乏技术升级空间，以及出差时间过长（一年300多天中有180天出差）。
下一份工作期望待遇提升、减少出差频率，并希望接触端到端和时空联合规划等新技术框架。
3、技术讨论：端到端与时空联合规划
时空联合规划方案多基于采样方法，通过评分和优化生成轨迹；端到端方案存在数据不足和模型缺陷（如copycat问题）。
新公司端到端方案预计明年6月上线，面试者可参与场景迭代，但需依赖模型团队提供初版。
端到端技术需与robust框架结合，部分模块（如control）可能上游化。
4、出差频率与工作安排
新公司出差频率因岗位而异，核心骨干出差较多，特殊场景迭代时需出差，但无强制驻场开发要求。
5、编程能力考察
面试者实现了一个模板类队列（链表结构），讨论了链表与数组的区别及C++新特性（如右值引用、optional）。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> {<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {<br>        T data;<br>        std::shared_ptr&lt;Node&gt; next;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">const</span> T&amp; val) : <span class="hljs-built_in">data</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) {}<br>    };<br><br>    std::shared_ptr&lt;Node&gt; front;  <span class="hljs-comment">// 队首指针</span><br>    std::weak_ptr&lt;Node&gt; rear;     <span class="hljs-comment">// 队尾指针（弱引用避免循环引用）</span><br>    <span class="hljs-type">size_t</span> count;                 <span class="hljs-comment">// 元素数量</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Queue</span>() : <span class="hljs-built_in">front</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">rear</span>(), <span class="hljs-built_in">count</span>(<span class="hljs-number">0</span>) {}<br><br>    <span class="hljs-comment">// 禁用拷贝构造和赋值（防止浅拷贝问题）</span><br>    <span class="hljs-built_in">Queue</span>(<span class="hljs-type">const</span> Queue&amp;) = <span class="hljs-keyword">delete</span>;<br>    Queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Queue&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-comment">// 移动构造</span><br>    <span class="hljs-built_in">Queue</span>(Queue&amp;&amp; other) <span class="hljs-keyword">noexcept</span> <br>        : <span class="hljs-built_in">front</span>(std::<span class="hljs-built_in">move</span>(other.front)), <span class="hljs-built_in">rear</span>(other.rear), <span class="hljs-built_in">count</span>(other.count) {<br>        other.count = <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 移动赋值</span><br>    Queue&amp; <span class="hljs-keyword">operator</span>=(Queue&amp;&amp; other) <span class="hljs-keyword">noexcept</span> {<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) {<br>            front = std::<span class="hljs-built_in">move</span>(other.front);<br>            rear = other.rear;<br>            count = other.count;<br>            other.count = <span class="hljs-number">0</span>;<br>        }<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    }<br><br>    <span class="hljs-comment">// 析构函数（智能指针自动释放内存）</span><br>    ~<span class="hljs-built_in">Queue</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-comment">// 入队操作</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span> </span>{<br>        <span class="hljs-keyword">auto</span> new_node = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(val);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) {<br>            front = rear = new_node;<br>        } <span class="hljs-keyword">else</span> {<br>            rear.<span class="hljs-built_in">lock</span>()-&gt;next = new_node;<br>            rear = new_node;<br>        }<br>        ++count;<br>    }<br><br>    <span class="hljs-comment">// 出队操作</span><br>    <span class="hljs-function">T <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>{<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">"Queue is empty"</span>);<br>        }<br>        <span class="hljs-keyword">auto</span> old_front = front;<br>        front = front-&gt;next;<br>        <span class="hljs-keyword">if</span> (!front) {  <span class="hljs-comment">// 如果队列变空</span><br>            rear.<span class="hljs-built_in">reset</span>();<br>        }<br>        --count;<br>        <span class="hljs-keyword">return</span> old_front-&gt;data;<br>    }<br><br>    <span class="hljs-comment">// 查看队首元素</span><br>    <span class="hljs-function">T <span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">"Queue is empty"</span>);<br>        }<br>        <span class="hljs-keyword">return</span> front-&gt;data;<br>    }<br><br>    <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<br>        <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;<br>    }<br><br>    <span class="hljs-comment">// 获取队列大小</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<br>        <span class="hljs-keyword">return</span> count;<br>    }<br><br>    <span class="hljs-comment">// 打印队列内容（调试用）</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{<br>        <span class="hljs-keyword">auto</span> current = front;<br>        <span class="hljs-keyword">while</span> (current) {<br>            std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="hljs-string">" "</span>;<br>            current = current-&gt;next;<br>        }<br>        std::cout &lt;&lt; std::endl;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 实现一个先入先出的队列</span><br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueNode</span> {<br>    T data;<br>    QueueNode *next;<br>    <span class="hljs-built_in">QueueNode</span>(<span class="hljs-type">const</span> T&amp; value) : <span class="hljs-built_in">data</span>(value), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) {} <span class="hljs-comment">// </span><br>};<br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> {<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Queue</span>() {} <span class="hljs-comment">// 构造函数</span><br>        ~<span class="hljs-built_in">Queue</span>() {<span class="hljs-built_in">clear</span>()} <span class="hljs-comment">// 析构函数</span><br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> &amp;T value)</span> </span>{ <span class="hljs-comment">// 入队方法</span><br>            <span class="hljs-comment">// 创建一个新的Queue节点</span><br>            QueueNode&lt;T&gt;* new_node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueueNode</span>&lt;T&gt;(value);<br>            <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) {<br>                front = new_node; <span class="hljs-comment">// 新入队的节点就是front</span><br>            } <span class="hljs-keyword">else</span> {<br>                rear-&gt;next = new_node;<br>                rear = new_node;<br>            }<br>            size++;<br>        }<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 出队方法</span><br>            <span class="hljs-comment">// 将node 出队列</span><br>            <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 判空</span><br>            QueueNode&lt;T&gt; *temp_node = front;<br>            front = front-&gt;next; <span class="hljs-comment">// 更新front指针</span><br>            <span class="hljs-keyword">delete</span> temp_node; <span class="hljs-comment">// 删除temp_node</span><br>            size--;<br>            <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) rear = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 如果队列为空，则rear指针为nullptr</span><br>        }<br><br>        <span class="hljs-comment">// 获取队列头</span><br><br>        <span class="hljs-function">T&amp; <span class="hljs-title">getFront</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">return</span> front-&gt;data;<br>        }<br><br>        <span class="hljs-function">T&amp; <span class="hljs-title">getRear</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">return</span> rear-&gt;data;<br>        }<br><br>        <span class="hljs-comment">// 清空</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>{<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) {<br>                <span class="hljs-built_in">pop</span>();<br>            }<br>        }<br>    <span class="hljs-keyword">private</span>:<br>        Queue&lt;T&gt;* front = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 队列的头</span><br>        Queue&lt;T&gt;* rear = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 队列的尾</span><br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>; <span class="hljs-comment">// 队列的长度</span><br>}<br></code></pre></td></tr></tbody></table></figure>
<p>对比以上内容，一个是指针，需要手动释放，一个是智能指针，不需要手动释放。</p>
<h3><span id="%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-vs-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">右值引用 vs 拷贝构造函数</span></h3>
<h4><span id="%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">核心概念</span></h4>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th>右值引用 (<code>T&amp;&amp;</code>)</th>
<th>拷贝构造函数</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>绑定对象</strong></td>
<td>临时对象（右值）</td>
<td>左值（具名对象）</td>
</tr>
<tr>
<td><strong>核心作用</strong></td>
<td>移动语义（资源转移）</td>
<td>深拷贝（创建独立副本）</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>延长临时对象生存期</td>
<td>无直接影响</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>临时对象处理、容器优化</td>
<td>对象复制、返回值</td>
</tr>
</tbody>
</table>
<hr>
<h4><span id="%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6">右值引用工作机制</span></h4>
<ol>
<li><strong>绑定规则</strong></li>
</ol>
<ul>
<li>仅能绑定<strong>右值</strong>（临时对象、<code>std::move</code>转换的左值）</li>
<li>通过<code>T&amp;&amp;</code>语法实现，避免拷贝开销</li>
</ul>
<ol start="2">
<li><strong>移动语义</strong></li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span> {<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Buffer</span>(Buffer&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(other.data) {<br>            other.data = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 资源转移</span><br>        }<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span>* data;<br>};<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>直接接管资源指针，源对象进入无效状态</li>
</ul>
<hr>
<h4><span id="%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%BC%94%E8%BF%9B">拷贝构造函数演进</span></h4>
<ol>
<li><strong>传统问题</strong></li>
</ol>
<ul>
<li><strong>浅拷贝风险</strong>：指针成员共享内存，导致双重释放</li>
<li><strong>性能瓶颈</strong>：大对象深拷贝耗时（如<code>std::vector</code>）</li>
</ul>
<ol>
<li><strong>现代优化</strong></li>
</ol>
<ul>
<li><strong>Rule of Five</strong>：自定义移动构造/赋值运算符</li>
<li><strong>智能指针</strong>：<code>std::unique_ptr</code>自动管理资源，避免手动深拷贝</li>
</ul>
<hr>
<h4><span id="%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94">关键代码对比</span></h4>
<p><strong>场景：字符串类资源管理</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 拷贝构造（深拷贝）</span><br><span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> MyString&amp; other) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[other.size]) {<br>    std::<span class="hljs-built_in">copy</span>(other.data, other.data + other.size, data);<br>}<br><span class="hljs-comment">// 移动构造（资源转移）</span><br><span class="hljs-built_in">MyString</span>(MyString&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(other.data) {<br>    other.data = <span class="hljs-literal">nullptr</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>拷贝构造</strong>：分配新内存并复制内容</li>
<li><strong>移动构造</strong>：直接接管指针，源对象置空</li>
</ul>
<hr>
<h4><span id="%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E4%B8%8E%E5%BB%BA%E8%AE%AE">性能对比与建议</span></h4>
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th>移动语义</th>
<th>拷贝构造</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>时间复杂度</strong></td>
<td>O(1)（仅指针操作）</td>
<td>O(n)（数据复制）</td>
</tr>
<tr>
<td><strong>内存分配</strong></td>
<td>复用临时对象内存</td>
<td>需要新内存空间</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>临时对象、资源回收</td>
<td>需要独立副本的场景</td>
</tr>
</tbody>
</table>
<p><strong>建议</strong>：</p>
<ol>
<li>优先使用移动语义处理临时对象</li>
<li>对需持久化的对象使用拷贝构造</li>
<li>结合<code>std::move</code>和<code>std::forward</code>实现完美转发</li>
</ol>
<h1><span id="hr%E9%9D%A2">HR面</span></h1>
<h2><span id="%E6%84%8F%E5%90%91%E5%BA%A6">意向度：</span></h2>
<p>很高，很靠前</p>
<h2><span id="%E8%96%AA%E8%B5%84">薪资：</span></h2>
<p>从底线往上给个区间，留有argue的余地</p>
<h2><span id="%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9C%8B%E5%A5%BD%E6%96%B0%E7%9F%B3%E5%99%A8%E7%9A%84%E6%9C%BA%E4%BC%9A">为什么看好新石器的机会</span></h2>
<p>落地机会：全球最大的L4级无人城配（RoboVan）解决方案提供商。覆盖顺丰、京东等头部客户，赛道内的独角兽。而且从现在的趋势看，人力成本的提高，自动驾驶的普及，这种无人配送是大势所趋。</p>
<p>三面的时候的面试官提到过是主机厂，不是tier 1。全链路闭环能力，省去了很多tier 1和主机厂交互沟通的效率浪费。</p>
<p>面试官也都很厉害，技术平台上是有一个学习机会，上升空间。L4级自动驾驶全栈研发（感知-决策-控制），接触无图导航、多模态融合等核心技术。</p>
<p>现在是一个发展的上升期，可以和平台一同成长</p>
<!-- hexo injector body_end start -->
<!-- Mermaid Scripts -->
<script>
// 检查页面是否包含Mermaid内容
const hasMermaid = document.querySelector('.mermaid') !== null;

// 如果存在Mermaid图表，则加载Mermaid库
if (hasMermaid) {
  // 加载Mermaid库
  const mermaidScript = document.createElement('script');
  mermaidScript.src = 'https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js';
  mermaidScript.onload = function() {
    mermaid.initialize({
      startOnLoad: true,
      theme: 'default',
      securityLevel: 'loose',
      fontFamily: 'inherit'
    });

    // 重新渲染Mermaid图表
    mermaid.init(undefined, '.mermaid');
  };
  document.head.appendChild(mermaidScript);
}
</script><!-- hexo injector body_end end --></body></html>
	</article>

	 
    <div class="kira-post-copyright">
        <strong>本文作者：</strong>战斗包子<br>
        <strong>本文链接：</strong><a href="https://paipai121.github.io/2025/11/07/%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E8%AF%95/%E6%96%B0%E7%9F%B3%E5%99%A8%E9%9D%A2%E8%AF%95/" title="https:&#x2F;&#x2F;paipai121.github.io&#x2F;2025&#x2F;11&#x2F;07&#x2F;工作&#x2F;面试&#x2F;新石器面试&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;paipai121.github.io&#x2F;2025&#x2F;11&#x2F;07&#x2F;工作&#x2F;面试&#x2F;新石器面试&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a>
		
	</div>
	
	<div class="kira-post-footer">
		

		
	<div class="giscus"></div>
  
    <script src="https://giscus.app/client.js"
      data-repo="PaiPai121/discuss"
      data-repo-id="R_kgDOMFuZdw"
      data-category="Announcements"
      data-category-id="DIC_kwDOMFuZd84Cf5yz"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="preferred_color_scheme"
      data-lang="zh-CN"
      data-loading="lazy"
      crossorigin="anonymous"
      async  
    ></script>
  

	</div>
	
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>

		</div>
	</body>
</html>
